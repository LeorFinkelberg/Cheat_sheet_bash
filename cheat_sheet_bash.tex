\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Практика использования и наиболее полезные конструкции командной оболочки \texttt{bash}}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Сценарии командной оболочки \texttt{bash}}

Для того чтобы успешно создать и запустить сценарий командной оболочки требуется:
\begin{enumerate}
	\item Написать сценарий,
	
	\item Сделать сценарий исполняемым,
	
	\item Поместить сценарий в каталог, где командная оболочка сможет найти его.
\end{enumerate}

Простой пример в качестве иллюстрации
\begin{lstlisting}[
style = bash,
title = {\sffamily bash\_test.sh},
numbers = none
]
#!/bin/bash
echo "This is number of command line args: $#"
\end{lstlisting}

Теперь нужно сделать этот файл исполняемым
\begin{lstlisting}[
style = bash,
numbers = none
]
$ chmod +x bash_test.sh
$ ls -l bash_test.sh
# выведет
# -rwxr-xr-x 1 ADM 197121 31 май 19 02:55 bash_test.sh*
\end{lstlisting}

Теперь можно вызывать этот скрипт
\begin{lstlisting}[
style = bash,
numbers = none
]
$ ./bash_test.sh 10 20
# выведет
# This is number of command line args: 2
\end{lstlisting}

\section{Конструкции оболочки bash}

Найти в корневом каталоге и всех подкатлогах (\texttt{/}), обычные файлы (\texttt{-type f}), измененные за последний день (\texttt{-mtime -l}), за исключением тех файлов, у которых есть суффикс \texttt{.o} (\texttt{! -name '*.o'})

\begin{lstlisting}[
language = cmd,
numbers = none
]
find / -type f -mtime -l ! -name '*.o'
\end{lstlisting}

Вывод имен файлов и удаление файлов с именами \texttt{core} или \texttt{junk} из рабочего каталога и всех его подкаталогов (круглые скобки обязательно отделяются пробелами)

\begin{lstlisting}[
language = cmd,
numbers = none
]
find . \( -name core -o -name junk \) -print -exec rm {} \;
\end{lstlisting}

Скопировать все \texttt{csv}-файлы из родительской директории (\texttt{..}) в текущую (\texttt{.})

\begin{lstlisting}[
language = cmd,
numbers = none
]
cp -ip ../*.csv
\end{lstlisting}

Скопировать файл из родительской директории в текущую директорию

\begin{lstlisting}[
language = cmd,
numbers = none
]
cp -ip ../Cheat_sheet_Git/cheat_sheet_git.tex .
\end{lstlisting}

Скопировать одну директорию в другую

\begin{lstlisting}[
language = cmd,
numbers = none
]
cp -rip ../Cheat_sheet_Git/style_packages/ .
\end{lstlisting}

Переименовать файл

\begin{lstlisting}[
language = cmd,
numbers = none
]
mv cheat_sheet_git.tex cheat_sheet_bash.tex
\end{lstlisting}

Найти все файлы с расширением \texttt{*.csv} и выбрать из них те, в которых содержится строка \texttt{'state'} (для каждого файла, отвечающего поисковому шаблону, запускается свой процесс)

\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -name '*.csv' -exec grep -niE 'state' {} \;
\end{lstlisting}

Вывести список файлов из текущей директории и всех поддиректорий

\begin{lstlisting}[
language = cmd,
numbers = none
]
ls -l *
\end{lstlisting}

Найти среди файлов с расширением \texttt{*.py} те, в именах которых есть подстрока \texttt{'spark'} (используется конвейер)

\begin{lstlisting}[
language = cmd,
numbers = none
]
ls -l *.py | grep -iE 'spark'
\end{lstlisting}

Найти файлы с расширением \texttt{*.py} и к каждому из них применить команду \texttt{grep}, которая будет искать в файле подстроку \texttt{'argparse'} без учета регистра, с выводом номера строки, на которой она нашла искомую строку по регулярному выражению \texttt{'argparse'} (работает {\color{deepred} медленно}, так как для каждого файла, отвечающего поисковому шаблону запускается свой процесс)

\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -maxdepth 1 -name '*.py' -exec grep -inE 'argparse' {} \;
\end{lstlisting}

Альтернативный вариант с использованием \texttt{xargs} (работает значительно быстрее варианта с \texttt{-exec})

\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -maxdepth 1 -name '*.py' | xargs grep -inE 'argparse'
\end{lstlisting} 

Найти в файлах с расширением \texttt{*.tex} строку \texttt{'section'} без учета регистра и вывести три строки контекста
\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -name '*.tex' | xargs grep -iE 'section' -3
\end{lstlisting}

Вывести список пакетов, в именах которых встречается подстрока \texttt{'python'} с контекстом \texttt{'sql'}
\begin{lstlisting}[
language = cmd,
numbers = none
]
conda list | grep -inE 'python.*sql'
\end{lstlisting}

Получить информацию о доступном метсе на диске
\begin{lstlisting}[
language = cmd,
numbers = none
]
df -h
\end{lstlisting}

Скачать файл с тем же именем, что на удаленном репозитории 
\begin{lstlisting}[
language = cmd,
numbers = none
]
curl -O http://merionet.ru/yourfile.tar.gz
\end{lstlisting}

Скачать файл с удаленного репозитория с новым именем и/или путем
\begin{lstlisting}[
language = cmd,
numbers = none
]
curl -o newfile.tar.gz http:// merionet.ru /yourfile.tar.gz
\end{lstlisting}

Возобновить прерванную загрузку с того места, где она остановилась
\begin{lstlisting}[
language = cmd,
numbers = none
]
curl -C - -O http://merionet.ru/yourfile.tar.gz
\end{lstlisting}

Скачать несколько файлов 
\begin{lstlisting}[
language = cmd,
numbers = none
]
curl -O http://merionet.ru/info.html -O http://wiki.merionet.ru/about.html
\end{lstlisting}


\subsection{Переадресация ввода-вывода}

Перенаправить \emph{стандартный поток вывода} данных (дескриптор файла 1) и \emph{стандартный поток вывода ошибок} (дескриптор файла 2), которые возвращает \texttt{conda} с захватом всех пакетов, в именах которых встречается подстрока \texttt{'python'}, в файл с именем \texttt{test\_file.log} (временный поток вывода данных \texttt{\&1}). Если команда вернет ошибку, то сообщение ошибки перепишет содержимое файла \texttt{test\_file.log}
\begin{lstlisting}[
language = cmd,
numbers = none
]
conda list | grep -inE 'python' > test_file.log 2>&1
\end{lstlisting}

Более короткий вариант рассмотренной выше конструкции
\begin{lstlisting}[
language = cmd,
numbers = none
]
conda list | grep -inE 'python' &> test_file.log
\end{lstlisting}

Присоединить стандартный поток вывода данных и стандартный поток вывода ошибок к содержимому файла. Конструкция \texttt{rm df} возвращает сообщение об ошибке <<\texttt{rm: cannot remove 'df': No such file or directory}>>, которое можно добавить в файл
\begin{lstlisting}[
language = cmd,
numbers = none
]
rm df &>> test_file.txt
\end{lstlisting}

Вывести размер директорий в Мегабайтах (\texttt{M})
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -BM
\end{lstlisting}

Вывести итоговый размер директории (\texttt{c}) в Мегабайтах (\texttt{M})
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -cBM
\end{lstlisting}

Перевести размеры директорий в понятный человеку формат
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -h
\end{lstlisting}

Вывести информацию об указанной директории в дружественном формате
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -sh style_packages/
\end{lstlisting}

Вывести размер папок текущей директории, не погружаясь глубже корневых папок
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -h -d 1
\end{lstlisting}
или так
\begin{lstlisting}[
language = cmd,
numbers = none
]
du --max-depth=1 -h
\end{lstlisting}

Вывести информацию об использовании дискового пространства иерархией каталога с подсчетом общего размера каталога и перенаправлением стандартного потока вывода ошибок в <<черную дыру>>
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -ch -d 1 2>/dev/null
\end{lstlisting}


% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{ Sobel-2011 }{ Собель М. Linux. Администрирование и системное программирование. 2-е изд. -- СПб.: Питер, 2011. -- 880 с. }
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\end{document}
