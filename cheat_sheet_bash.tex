\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Практика использования и наиболее полезные конструкции командной оболочки \texttt{bash}}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Сценарии командной оболочки \texttt{bash}}

\subsection{Особенности обработки выражений, заключенных в кавычки}

Строка в форме \verb|$'...'| умеет обрабатывать управляющие последовательности
\begin{lstlisting}[
style = bash,
numbers = none
]
$ echo $'python\nfortran'
# выведет две строки, разбитые символом перевода строки
# python
# fortran
\end{lstlisting}

Строка в форме \verb|"..."| умеет корректно обрабатывать подстановку значений переменных, арифметических выражений и подстановку команд
\begin{lstlisting}[
style = bash,
numbers = none
]
$ EMAIL = 'leor.finkelberg@yandex.ru'
$ echo $EMAIL  # leor.finkelberg@yandex.ru
$ echo "My email: '$EMAIL'"  # My email:'leor.finkelberg@yandex.ru'
$ echo "In this catalogy `ls -l | wc -l` files"  # In this catalogy 10 files
$ echo "$INT % 2 -> $(($INT % 2))"  # 8 % 2 -> 0
$ echo "result = <<`find . -name 'cheat*.tex' | xargs grep -inE 'tab.*ofcont*'`>>"
                                                      # result = <<21:\tableofcontents>>
\end{lstlisting}



\subsection{Переменные, встроенные в оболочку}



\subsection{Формат файла сценария}

Для того чтобы успешно создать и запустить сценарий командной оболочки требуется:
\begin{enumerate}
	\item Написать сценарий,
	
	\item Сделать сценарий исполняемым,
	
	\item Поместить сценарий в каталог, где командная оболочка сможет найти его.
\end{enumerate}

Простой пример в качестве иллюстрации
\begin{lstlisting}[
style = bash,
title = {\sffamily bash\_test.sh},
numbers = none
]
#!/bin/bash
echo "This is number of command line args: $#"
\end{lstlisting}

Сочетание символов \verb|#!| -- это специальная конструкция, которая называется \emph{shebang} (произносится как <<ше-бенг>>) и сообщает системе имя интерпретатора, который должен использоваться для выполнения следующего за ним текста сценария. Каждый сценарий командной оболочки должен включать это определение в первой строке.

Команда <<точка>> (\texttt{.}) является синонимом \texttt{source}, встроенной команды, которая читает указанный файл и интерпретирует его как ввод с клавиатуры \cite[\strbook{349}]{shotts:linux-2017}.

\subsection{Разрешение на выполнение}

Теперь нужно сделать этот файл исполняемым
\begin{lstlisting}[
style = bash,
numbers = none
]
$ chmod +x bash_test.sh
$ ls -l bash_test.sh
# выведет
# -rwxr-xr-x 1 ADM 197121 31 май 19 02:55 bash_test.sh*
\end{lstlisting}

Проиндексировать файл и сделать его исполняемым можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
$ git add --chmod=+x file.sh
\end{lstlisting}

\subsection{Местоположение файла сценария}

Теперь можно вызывать этот скрипт
\begin{lstlisting}[
style = bash,
numbers = none
]
$ ./bash_test.sh 10 20
# выведет
# This is number of command line args: 2
\end{lstlisting}

Но чтобы вызвать сценарий, необходимо добавить явный путь перед его именем. Для того чтобы можно было вызывать этот сценарий из любой точки системы, следует добавить его в переменную окружения \texttt{PATH}. Как известно, система просматривает каталоги по списку всякий раз, когда требуется найти исполняемую программу, если путь к ней не указан явно. Список каталогов храниться в как раз в переменной окружения \texttt{PATH}.

Она содержит список каталогов, перечисленных через двоеточие
\begin{lstlisting}[
style = bash,
numbers = none
]
$ echo $PATH
# выведет
# /c/Users/ADM/bin:/mingw64/bin:/usr/local/bin:/usr/bin:/bin:/mingw64/bin:/usr/bin:\
# /c/Users/ADM/bin:/c/Program Files (x86)/Common Files/Oracle/Java/javapath:\
# /c/Program Files (x86)/Intel/iCLS Client:/c/Program Files/Intel/iCLS Client ... etc
\end{lstlisting}

К слову, для более удобного просмотра вывода (пути разделяются символом <<\texttt{:}>>), можно воспользоваться следущей процедурой с привлечением редактора \texttt{Vim}:
\begin{itemize}
	\item Перенаправляем стандартный поток вывода в файл \texttt{paths.txt}: \\\verb|echo $PATH > paths.txt|
	
	\item Открываем файл редактором \texttt{Vim}\\\verb|vim paths.txt|
	
	\item Сочетанием клавиш \texttt{qa}\footnote{Начать запись в именованный регистр \texttt{"a}} открываем журнал записи пользовательских сценариев (внизу экрана появится строка <<\verb|запись @a|>>),
	
	\item Теперь можно выполнить нужную нам последовательность команд для первого символа <<\texttt{:}>>. Например \verb|f:xi<CR><Esc>q|, что означает следующее: найти слева направо символ <<\texttt{:}>>, удалить символ, который будет находится под курсором (т.е. символ <<\texttt{:}>>), перейти в режим ВСТАВКИ (\texttt{i}), нажать клавишу \texttt{Enter} для перехода на следующую строку в режиме ВСТАВКИ, нажать клавишу \texttt{Esc} для выхода из режима ВСТАВКИ и, наконец, закончить запись (\texttt{q})\footnote{Проверить содержимое регистра можно так \texttt{:reg a}},
	
	\item Записав сценарий, можно воспользоваться командой \texttt{normal}\footnote{Здесь задается произвольное большое число, указывающее число повторений команды. Еще очень важный момент заключается в том, что эта команда выполняется параллельно, а не последовательно} \\\verb|:%normal! 100@a|
\end{itemize}

Результат будет выглядеть так
\begin{lstlisting}[
numbers = none
]
/c/Users/ADM/bin
/mingw64/bin
/usr/local/bin
/usr/bin
/bin
/mingw64/bin
\end{lstlisting}

В большинстве \texttt{Unix}-подобных операционных систем в переменную \texttt{PATH} включается каталог \verb|bin| в \emph{домашнем каталоге пользователя}, чтобы дать пользователям выполнять собственные программы.

То есть если создать каталог \verb|~/bin| и поместить сценарий в него, то наш сценарий можно будет запускать из любой точки системы
\begin{lstlisting}[
numbers = none
]
$ mkdir ~/bin
$ mv bash_test.sh ~/bin
\end{lstlisting}

Если каталог отсутствует в переменной \verb|PATH|, его легко туда добавить, включив следующую строку в файл \verb|~/.bash_profile|
\begin{lstlisting}[
numbers = none
]
export PATH=~/bin:${PATH}
\end{lstlisting}

Команда \texttt{export} устанавливает \emph{переменную окружения}, или другими словами экспортирует переменную, делая ее {переменной окружения}. Здесь <<\texttt{:}>> это просто символ-разделитель, а конструкция \verb|${PATH}| разворачивается в список путей, разделенных символом <<\texttt{:}>>.

\subsection{Выбор местоположения для сценариев}

Каталог \verb|~/bin| хорошо подходит для сценария, если этот сценарий предназначен для \emph{личного} использования. Сценарии, которые должны быть доступны \emph{всем} пользователям в системе, лучше размещать в традиционном местоположении -- в каталоге \verb|/usr/local/bin|.

В большинстве случаев программное обеспечение созданное в \emph{локальной} системе, будь то сценарий или скомпилированные программы, следует помещать в иерархию каталогов \verb|/usr/local|, а не \verb|/bin| или \verb|/usr/bin|. Последние два каталога, как определено стандартом иерархии файловой системы \texttt{Linux}, предназначены только для файлов, поставляемых создателями дистрибутива \texttt{Linux}.

\subsection{Присваивание значений переменным и константам}

Командная оболочка не заботиться о типах значений, присваиваемых переменным. Она все значения интерпретирует как \emph{строки}. Между именем переменной и оператором присваивания не должно быть пробелов. Значение может состоять из чего угодно, что можно развернуть в строку
\begin{lstlisting}[
style = bash,
numbers = none
]
a=z                  # Присвоить переменной a строку "z"
b="a string"         # Внутренние пробелы должны находиться в кавычках
c="a string and $b"  # При присваивании допускается выполнять подстановку,
                     # например, значений других переменных
d=$(ls -l foo.txt)   # Результат выполнения команды
e=$((5*7))           # Подстановка результата арифметического выражения
f="\t\ta string\n"   # Экранирование последовательности, такие как
                     # символы табуляции и перевода строки
\end{lstlisting}

При использовании подстановки имена переменных можно заключить в \emph{необязательные фигурные скобки} \verb|{}|. Это пригодится в том случае, когда имя переменной становится неоднозначным в окружающем контексте.

Например
\begin{lstlisting}[
numbers = none
]
$ filename="myfile"
$ touch $filename
$ mv $filename ${filename}1  # переименовывает файл myfile -> myfile1
\end{lstlisting}

Добавив фигурные скобки, мы гарантировали, что командная оболочка не будет интерпретировать последний символ \texttt{1} как часть имени новой (и пустой) переменной.

Существует еще один метод вывода текста, который называется \emph{встроенным документом} или \emph{встроенным сценарием}. Встроенный документ -- это дополнительная форма перенаправления ввода/вывода, которая передает текст, встроенный в сценарий, на стандартный ввод команд.

Действует это перенаправление так:
\begin{lstlisting}[
numbers = none
]
команда << индикатор
текст
индикатор
\end{lstlisting}

Например
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

TITLE="System Information Report Fort $HOSTNAME"
CURRENT_TIME=$(date +"%x %r %Z")
TIME_STAMP="Generated $CURRENT_TIME, by $USER"

cat << _EOF_
<HTML>
    <HEAD>
        <TITLE>$TITLE</TITLE>
    </HEAD>
    <BODY>
        <H1>$TITLE</H1>
        <P>$TIME_STAMP</P>
    </BODY>
</HTML>
_EOF_
\end{lstlisting}

К слову, для того чтобы заменить \verb|$name| на \verb|${name}| в сценарии можно воспользоваться такой конструкцией
\begin{lstlisting}[
style =bash,
numbers = none
]
:%s/>\$\(.*\)</>${\1}</c
------------------------
:%s  # произвести замену во всех строках файла
   /  # разделитель
    >\$\(.*\)<  # поисковый шаблон; например, >$TITLE<
              /  # разделитель
               >${\1}<  # шаблон подстановки
                      /c  # замена с подтверждением по каждому совпадению
\end{lstlisting}

Эта конструкция ищет совпадение с шаблоном во \emph{всех} строках сценария (\verb|%|). Подшаблон \verb|>\$\(.*\)<| совпадает, например, с подстрокой \verb|>$TITLE<|, и при этом \texttt{TITLE} попадает в группу №1 (к ней можно обращаться как \verb|\1|). Теперь можно \verb|>$TITLE<| заменить на \verb|>${\1}<|. Эта часть шаблона воспринимается <<как есть>>, т.е. ничего дополнительно экранировать не нужно. Параметр \texttt{c} требует подтверждение замены каждый раз, когда находит подстроку отвечающую поисковому шаблону.

На роль индикатора была выбрана строка \verb|_EOF_|, и она отмечает конец встроенного текста. Строка-индикатор должна находиться в отдельной строке, одна, и за ней не должно следовать никаких пробелов.

Если заменить оператор перенаправления \verb|<<| на \verb|<<-|, то командная оболочка будет игнорировать начальные символы табуляции во встроенном документе. Для того чтобы блок встроенного документа работал корректно для форматирования тела блока необходимо использовать только ТАБУЛЯЦИЮ, поэтому в \texttt{Vim} придется отключить преобразование табуляции в пробелы (закомментировать строку \verb|set expandtab|). Благодаря этому во встроенный документ можно добавить отступы для большей удобочитаемости
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

FTP_SERVER=ftp.nl.debian.org
FTP_PATH=/debian/dists/lenny/main/installer-i386/current/images/cdrom
REMOTE_FILE=debian-cd_info.tar.gz

ftp -n <<- _EOF_
    open $FTP_SERVER            # здесь строго ТАБУЛЯЦИЯ!
    user anonymous me@linuxbox  # здесь строго ТАБУЛЯЦИЯ!
    cd $FTP_PATH                # здесь строго ТАБУЛЯЦИЯ!
    hash                        # здесь строго ТАБУЛЯЦИЯ!
    get $REMOTE_FILE            # здесь строго ТАБУЛЯЦИЯ!
    bye                         # здесь строго ТАБУЛЯЦИЯ!
    _EOF_                       # здесь строго ТАБУЛЯЦИЯ!
ls -l $REMOTE_FILE
\end{lstlisting}

Еще можно перенаправлять вывод, организованный с помощью \verb|<<-|, в файл
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

USER="leor.finkelberg"

report_home_space () {
    if [[ $(id -u) -eq 0 ]]; then
        cat <<- _EOF_ > ./contfile.txt  # <- NB          # здесь строго ТАБУЛЯЦИЯ!
            <H2>Home Space Utilization (All Users)</H2>  # здесь строго ТАБУЛЯЦИЯ!
            <PRE>$(du -sh .)</PRE>                       # здесь строго ТАБУЛЯЦИЯ!
            _EOF_                                        # здесь строго ТАБУЛЯЦИЯ!
...
\end{lstlisting}

Конструкция \verb|cat <<- _EOF_ > ./contfile.txt| перезаписывает файл \texttt{contfile.txt} при каждом запуске сценария. Если требуется <<дозаписать>> файл, то следует использовать конструкцию \verb|cat <<- _EOF_ >> ./contfile.txt|.

Можно вывод команды \texttt{cat} направить как в стандартный поток вывода (терминал), так и в файл с помощью команды \texttt{tee}\footnote{Утилита \texttt{tee} копирует стандартный ввод на стандартный вывод, а также в один или несколько файлов \cite{sobel:linux-2011}}
\begin{lstlisting}[
style = bash,
numbers = none
]
report_home_space () {
    if [[ $(id -u) -eq 0 ]]; then
        cat <<- _EOF_ | tee ./contfile.txt  # <- NB
                ...
                _EOF_
    ...
}
\end{lstlisting}

Без ключей утилита \texttt{tee} переписывает файл вывода, если они существуют, и реагирует на прерывания. Ключ \verb|-a| заставляет утилиту добавлять вывод к существующим файлам вместо их переписывания.

\subsection{Функции}

Функции имеют две синтаксические формы. Первая выглядит так
\begin{lstlisting}[
numbers = none
]
function fun_name {
    commands
    return 
}
\end{lstlisting}

Вторая форма выгладит так
\begin{lstlisting}[
numbers = none
]
fun_name () {
    commands
    return
}
\end{lstlisting}

Обе формы эквивалентны и могут использоваться одна вместо другой. Ниже приводится сценарий, демонстрирующий использование функций командной оболочки
\begin{lstlisting}[
style = bash
]
#!/bin/bash

function funct {
    echo "Step 2"
    return
}

echo "Step 1"  # Step 1
funct          # Step 2
echo "Step 3"  # Step 3
\end{lstlisting}

Когда командная оболочка читает сценарий, она пропускает строки с 1-ой по 7-ую, так как они содержат только определение функции. Выполнение начинается со строки 8 с команды \texttt{echo}. Строка 9 вызывает функцию \texttt{funct}, и командная оболочка выполняет функцию как любую другую команду. Управление передается в строку 4, и выполняется вторая команда \texttt{echo}.

Команда \texttt{return} в этой строке завершает выполнение функции и возвращает управление в строку, следующую за вызовом функции. После этого выполняется заключительная команда \texttt{echo}. Функции должны быть определены в сценарии до их вызова.

Имена функций подчиняются тем же правилам, что и имена переменных. Функция должна содержать хотя бы одну команду. Команда \texttt{return} (которая является необязательной) помогает удовлетворить это требование.

Примеры использования функций с \emph{локальными переменными}

\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

foo=0  # глобальная переменная

funct_1 () {
    local foo  # переменная `foo` локальная для `funct_1`
    foo=1
    echo "funct_1: foo = $foo"
}

# для вызова функции
funct_1
\end{lstlisting}

Локальные переменные объявляются добавлением слова \texttt{local} перед именем переменной. В результате создается переменная, локальная по отношению к функции, в которой она определена. Когда выполнение выйдет за пределы функции, переменная перестанет существовать.

Рассмотрим такую функцию
\begin{lstlisting}[
style = bash,
numbers = none
]
report_disk_space () {
    cat <<- _EOF_                        # здесь строго ТАБУЛЯЦИЯ!
        <H2>Disk Space Utilization</H2>  # здесь строго ТАБУЛЯЦИЯ!
        <PRE>$(df -h)</PRE>              # здесь строго ТАБУЛЯЦИЯ!
        _EOF_                            # здесь строго ТАБУЛЯЦИЯ!
    return
}

# вызов функции
report_disk_space
\end{lstlisting}

Она получает информацию о дисковом пространстве с помощью команды \verb|df -h|.

\subsection{Ветвление}

Инструкция \texttt{if} имеет следующий синтаксис
\begin{lstlisting}[
style = bash,
numbers = none
]
if commands; then
    commands
[elif commands; then
    commands...]
[else
    commands]
fi
\end{lstlisting}

В командной оболочке \texttt{bash} поддерживается еще один способ ветвления. Операторы \verb|&&| и \verb|||| действуют подобно логическим операторам в составной команде \verb|[[...]]|. Они имеют следующий синтаксис
\begin{lstlisting}[
style = bash,
numbers = none
]
command1 && command2
\end{lstlisting}
и
\begin{lstlisting}[
style = bash,
numbers = none
]
command1 || command2
\end{lstlisting}

В последовательности с оператором \verb|&&| первая команда выполняется всегда, а вторая -- только если первая завершилась успешно. В последовательности с оператором \verb|||| первая команда выполняется всегда, а вторая -- только если первая завершилась неудачей.

Например
\begin{lstlisting}[
style = bash,
numbers = none
]
# если каталога `temp` не существует, то его нужно создать
$ [[ -d temp ]] || mkdir temp
\end{lstlisting}


\subsection{Современная версия команды test}

Улучшенная версия команды \texttt{test} выглядит так
\begin{lstlisting}[
style = bash,
numbers = none
]
[[ выражение ]]
\end{lstlisting}

Команда \texttt{test} и ее формы (\verb|[...]|, \verb|[[...]]|) возвращают \emph{код завершения}, показывающий, что выражение либо истинно -- \texttt{true} (0), либо ложно -- \texttt{false} (не 0). А вот самое \texttt{выражение} возвращает истинное (\texttt{true}) или ложное (\texttt{false}) значение.

Команда \verb|[[...]]| очень похожа на команду \verb|[...]|, но добавляет новое выражение для проверок строк \verb|строка1 =~ регулярное_выражение|.

Например можно проверить отвечает ли заданное число регулярному выражению
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

INT=-5

if [[ "$INT" =~ ^-?[0-9]+$ ]]; then
    if [ $INT -eq 0 ]; then
        echo "INT is zero."
    else
        if [ $INT -lt 0 ]; then
            echo "INT is negative."
        else
            echo "INT is positive."
        fi
        if [ $((INT % 2 )) -eq 0 ]; then
            echo "INT is even."
        else
            echo "INT is odd."
        fi
    fi
else
    echo "INT is not an integer." >&2
    exit 1
fi
\end{lstlisting}

В команде \verb|[[...]]| поддерживаются \emph{классы символов}\footnote{Класс символов POSIX состоит из ключевых слов, заключенных между \texttt{[:} и \texttt{:]}. Эти конструкции должны находится в квадратных скобках скобкового выражения. Например, \texttt{[[:alpha:]!]} соответствует любому одиночному символу или восклицательному знаку \cite[\strbook{98}]{robbins:vim-2013}} POSIX. Ключевые слова описывают различные классы символов, такие как алфавитные, управляющие символы и пр. POSIX, например
\begin{lstlisting}[
style = bash,
numbers = none
]
$ EMAIL="leor.finkelberg@yandex.ru"
$ if [[ "$EMAIL" =~ ^[[:alpha:]]+\.[[:alpha:]]+@[[:alpha:]]+\.ru$ ]]; then echo 'OK'; fi
\end{lstlisting}

Еще одна дополнительная особенность \verb|[[...]]|: оператор \verb|==| поддерживает сопоставление с шаблонами по аналогии с механизмом подстановки путей. Например
\begin{lstlisting}[
style = bash,
numbers = none
]
$ FILE="foo.bar"
$ if [[ $FILE == foo.* ]]; then
> echo "$FILE matches pattern 'foo.*'"
>fi
# foo.bar matches pattern 'foo.*'
\end{lstlisting}

Или можно воспользоваться регулярным выражением
\begin{lstlisting}[
style = bash,
numbers = none
]
$ FILE="foo.bar"
$ if [[ $FILE =~ ^foo\..+$ ]]; then echo 'OK'; fi
# OK
\end{lstlisting}

В дополнение к составной команде \verb|[[...]]| \texttt{bash} поддерживает также составную команду \verb|((...))|, которую удобно использовать для работы с целыми числами.

Команда \verb|((...))| применяется для \emph{проверки истинности арифметических выражений}. Арифметическое выражение считается \emph{истинным}, если его \emph{результат отличается от нуля}.

Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

INT=-5

if [[ "$INT" =~ ^-?[0-9]+$ ]]; then
    if (( $INT == 0 )); then
        echo "INT is zero."
    ...
    fi
    if (( $INT % 2 )); then
        echo "INT is even."
    else
        echo "INT is odd."
...
\end{lstlisting}

\subsection{Объединение выражений}

Команда \verb|[[...]]| поддерживает три логические операции: И (\verb|&&|), ИЛИ (\verb||||) и НЕ (\verb|!|).

Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

MIN_VAL=1
MAX_VAL=100
INT=50

if [[ "$INT" =~ ^-?[0-9]+$ ]]; then
    if [[ INT -ge MIN_VAL && INT -le MAX_VAL ]]; then
        echo "$INT is whithin $MIN_VAL to $MAX_VAL."
    else
        echo "$INT is out of range."
    fi
else
    else "INT is not an integer." >&2
    exit 1
fi
\end{lstlisting}

Логические блоки можно заключать в круглые скобки
\begin{lstlisting}[
style = bash,
numbers = none
]
...
if [[ ($INT -lt 0) && ($INT -gt 10) ]]; then
    echo ...
\end{lstlisting}

Еще с \verb|[[...]]| можно сочетать подстановку \verb|$(...)| и вычисления \verb|(...)|
\begin{lstlisting}[
style = bash,
numbers = none
]
...
if [[ ($INT -gt 0) && $(($INT % 2)) -eq 0 ]]; then
    echo ...
\end{lstlisting}

Узнать имеет ли текущий пользователь права на чтение всех домашних каталогов можно следующим образом
\begin{lstlisting}[
style = bash,
numbers = none
]
USER="leor.finkelberg"

report_home_space () {
    if [[ $(id -u) -eq 0 ]]; then
        cat <<- _EOF_                                    # здесь строго ТАБУЛЯЦИЯ!
            <H2>Home Space Utilization (All Users)</H2>  # здесь строго ТАБУЛЯЦИЯ!
            <PRE>$(du -sh .)</PRE>                       # здесь строго ТАБУЛЯЦИЯ!
            _EOF_                                        # здесь строго ТАБУЛЯЦИЯ!
    else
        cat <<- _EOF_                                    # здесь строго ТАБУЛЯЦИЯ!
            <H2>Home Space Utilization ($USER)</H2>      # здесь строго ТАБУЛЯЦИЯ!
            <PRE>$(du -sh $HOME)</PRE>                   # здесь строго ТАБУЛЯЦИЯ!
            _EOF_                                        # здесь строго ТАБУЛЯЦИЯ!
    fi
    return    
}

report_home_space
\end{lstlisting}

\subsection{Чтение и ввод с клавиатуры}

Команда \texttt{read} используется для чтения единственной строки со стандартного ввода. Синтаксис
\begin{lstlisting}[
style = bash,
numbers = none
]
read [-parameters] [var ...]
\end{lstlisting}

Если имя переменной не указано, строка с данными сохраняется в переменную \texttt{REPLY}.

Например, для того чтобы пользователь мог задать имя файла, в который сценарий будет перенаправлять вывод \verb|<<-|, можно воспользоваться ключом \texttt{-r}

\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

read -p "Enter filename: " filename  # <-

report_home_space () {
    if [[ $(id -u) -eq 0 ]]; then
        cat <<- _EOF_ | tee ./$filename  # <-
            ...
        _EOF_
    ...
}
\end{lstlisting}

Еще один простой пример
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

# читает пользовательский ввод
read -p "Enter integer number: " int

if [[ "$int" =~ ^-?[[:digit:]]+$ ]]; then
    if [ $int -eq 0 ]; then
        echo "$int is zero."
    else
        if [ $int -lt 0 ]; then 
            echo "$int is negative."
        else
            echo "$int is positive."
        fi
        if [ $((int % 2)) -eq 0 ]; then
            echo "$int is even."
        else
            echo "$int is odd."
        fi
    fi
else
    echo "Input value is not an integer." >&2
    exit 1
fi
\end{lstlisting}

Для того чтобы прочитать несколько значений, следует воспользоваться такой конструкцией
\begin{lstlisting}[
style = bash,
numbers = none
]
read -p "Enter one or more values > " var1 var2 var3 var4 var5

echo "var1 = '$var1'"
echo "var2 = '$var2'"
echo "var3 = '$var3'"
echo "var4 = '$var4'"
echo "var5 = '$var5'"
\end{lstlisting}

С помощью ключа \verb|-s| можно скрывать символы при вводе, а с помощью ключа \verb|-t| устанавливать время ожидания на ввод. Например
\begin{lstlisting}[
style = bash,
numbers = none
]
if read -t 10 -sp "Enter secret passphrase > " secret_pass; then
    echo -e "\nSecret passphrase = '$secret_pass'" 
    # флаг -e нужен для интерпретации управляющей последовательности
...
\end{lstlisting}

Здесь пользователю предлагается ввести секретный пароль за отведенные 10 сек. Если в течение этого времени ввод не был завершен, сценарий завершается с кодом ошибки. Поскольку в команду включен параметр \verb|-s|, символы пароля не выводятся на экран в процессе ввода.

\subsection{Выделение полей в строке ввода с помощью IFS}

Обычно командная оболочка выполняте разбиение ввода на слова перед передачей его команде \texttt{read}. Слова во вводе, разделенные одним или несколькими пробелами, становятся отдельными значениями и присваиваются командой \texttt{read} разным переменным.

Такое поведение командной оболочки регулируется переменной \texttt{IFS} (Internal Field Separator). По умолчанию переменная \texttt{IFS} хранит символы пробела, табуляции и перевода строки, каждый из которых может служить разделителем полей.

Изменяя значение переменной \texttt{IFS}, можно управлять делением ввода на поля перед передачей команде \texttt{read}. Например, пусть файл \verb|/etc/passwd| хранит строки данных, в которых поля отделяются друг от друга двоеточием. Присвоив переменной \texttt{IFS} значение, состоящее из единственного двоеточия, можно с помощью \texttt{read} прочитать содержимое \verb|/etc/passwd| и благополучно разделить строки на поля для присваивания разным переменным. Ниже приводится сценарий, который именно так и действует
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

# файл должен существовать до обращения и иметь
# содержание вида Leor:100:34345:Leor Finkelberg:~:bash
FILE="./passwd.txt"

# строка-приглашение
read -p "Enter a username > " user_name  # вводим, например, leor

# благодаря флагу `-i` имя пользователя можно задавать в нижнем регистре
# подстановка $user_name отрабатывает раньше, чем поиск по регулярному выражению
file_info=$(grep -iE "^$user_name:" $FILE)  # одна единственная строка из файла ./passwd.txt

if [[ -n "$file_info" ]]; then  # если строка непустая, то...
    IFS=":" read user pw uid gid name home shell <<< "$file_info"  # <-
    echo "User = '$user'"
    echo "UID = '$uid'"
    echo "GID = '$gid'"
    echo "Full Name = '$name'"
    echo "Home Dir. = '$home'"
    echo "Shell = '$shell'"
else
    echo "No such user '$user_name'" >&2
    exit 1
fi
\end{lstlisting}

Командная оболочка позволяет выполнять в одной строке одно или несколько операций присваивания значений переменным непосредственно \emph{перед} командной, на поведение которой эти переменные влияют. Они \emph{изменяют окружение}, в котором выполняется команда. Действие этих операций присваивания ности \emph{временный} характер, окружение изменяется только на время выполнения команды. В данном случае в переменной \texttt{IFS} сохраняет символ двоеточия.

То же самое можно выразить иначе
\begin{lstlisting}[
style = bash,
numbers = none
]
OLD_IFS="$IFS"
IFS=":"
read user pw uid gid name home shell <<< "$file_info"
IFS="$OLD_IFS"
\end{lstlisting}

Очевидно, что размещение операции присваивания перед командой позволяет получить более компактный код, действующий точно так же.

Оператор \verb|<<<| отмечает \emph{встроенную строку}. Встроенную строку (here string) простирается только до конца текущей строки кода. В данном примере строка из файла подается на стандартный ввод команды \texttt{read}.

Вот несколько любопытных примеров работы со \emph{встроенной строкой}
\begin{lstlisting}[
style = bash,
numbers = none
]
$ string="This is a string of words."
$ read -r -a words <<< "$string"
$ echo "${words[0]}"  # This
$ echo "${words[1]}"  # is
...
\end{lstlisting}

Удобно тестировать регулярное выражение с помощью команды \texttt{grep}
\begin{lstlisting}[
style = bash,
numbers = none
]
$ grep -iE '(P|J)ython' <<< 'Jython'
$ grep -iE '[[:alpha:]]+\.[[:alpha:]]+@[[:alpha:]]+\.ru' <<< 'leor.finkelbex.ru'
\end{lstlisting}

\subsection{Проверка ввода}

Далее приводится пример программы, проверяющий входные данные разного вида
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

clear  # очистить экран перед началом работы программы

invalid_input () {
    echo "Invalid input '$REPLY'" >&2
    exit 1
}

# переменная явно не указана, поэтому
# пользовательский ввод будет связан с переменной REPLY
read -p "Enter a single item > "

# пустой ввод (недопустимо!); если строка пустая, то вызывается функция `invalid_input`
[[ -z $REPLY ]] && invalid_input
# если в переданной строке более одного слова, вызывать функцию `invalid_input`
# ((...)) -> [true|false]
(( $(echo $REPLY | wc -w) > 1 )) && invalid_input

# введено допустимое имя файла
if [[ $REPLY =~ ^[-[:alnum:]\._]+$ ]]; then
    echo "'$REPLY' is a valid filename."
    if [[ -e $REPLY ]]; then
        echo "And file '$REPLY' exists."
    else
        echo "However, file '$REPLY' does not exists."
    fi

    if [[ $REPLY =~ ^-?[[:digit:]]*\.[[:digit:]]+$ ]]; then
        echo "'$REPLY' is a floating point number."
    else
        echo "'$REPLY' is not a floating point number."
    fi

    if [[ $REPLY =~ ^-?[[:digit:]]+$ ]]; then
        echo "'$REPLY' is an integer."
    else
        echo "'$REPLY' is not an integer."
    fi
else
    echo "The string '$REPLY' is not a valid filename."
fi
\end{lstlisting}

Для проверки числа слов в пользовательском вводе с тем же результатом можно было бы использовать и конструкцию
\begin{lstlisting}[
style = bash,
numbers = none
]
[[ $(echo "$REPLY" | wc -w) -gt 1 ]] && invalid_input
\end{lstlisting}

\subsection{Циклы}

Синтаксис цикла с командой \texttt{while} выглядит так
\begin{lstlisting}[
style = bash,
numbers = none
]
while commands; do
    commands
done
\end{lstlisting}

Подобно \texttt{if}, команда \texttt{while} проверяет \emph{код завершения} списка команд. Пока код завершения равен 0, она выполняет команды внутри цикла. В сценарии, приведенном выше, создается переменная \texttt{count}, и ей присваивается начальное значение 1. Команда \texttt{while} проверяет код завершения команды \texttt{test}. Пока \texttt{test} возвращает код 0, команды внутри цикла продолжают выполнятся. В конце каждого цикла повторно выполняется команда \texttt{test}. После шести итераций цикла значение переменной \texttt{count} увеличится до 6, команда \texttt{test} вернет код завершения, отличный от 0, и цикл завершится, а программа продолжит выполнение с инструкцией, следующей непосредственно за циклом.

Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

DELAY=2  # время отображения результатов на экране (в секундах)

while [[ $REPLY != 0 ]]; do
    clear
    cat <<- _EOF_                          # строго ТАБУЛЯЦИЯ
        Please Select:                     # строго ТАБУЛЯЦИЯ
                                           # строго ТАБУЛЯЦИЯ
        1. Display System Information      # строго ТАБУЛЯЦИЯ
        2. Display Disk Space              # строго ТАБУЛЯЦИЯ
        3. Display Home Space Utilization  # строго ТАБУЛЯЦИЯ
        0. Quit                            # строго ТАБУЛЯЦИЯ
                                           # строго ТАБУЛЯЦИЯ
    _EOF_                                  # строго ТАБУЛЯЦИЯ
    read -p "Enter selection [0-3] > "  # приглашение к вводу

    if [[ $REPLY =~ ^[0-3]$ ]]; then
        if [[ $REPLY == 1 ]]; then
            echo "Hostname: $HOSTNAME"
            echo uptime
            sleep $DELAY
        fi
        if [[ $REPLY == 2 ]]; then
            df -h
            sleep $DELAY
        fi
        if [[ $REPLY == 3 ]]; then
            if [[ $(id -u) -eq 0 ]]; then
                echo "Home Space Utilization (All Users)"
                du -sh
            else
                echo "Home Space Utilization ($USER)"
                du -sh $HOME/Roaming
            fi
            sleep $DELAY
        fi
    else
        echo "Invalid entry."
        sleep $DELAY
    fi
done
echo "Program terminated."
\end{lstlisting}

Можно переписать эту программу с использованием команд \texttt{continue} и \texttt{break}
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

DELAY=2
USER="leor.finkelberg"

while true; do
    clear
    cat <<- _EOF_
        Please Select:

        1. Display System Information
        2. Display Disk Space
        3. Display Home Space Utilization
        0. Quit

    _EOF_
    read -p "Enter selection [0-3] > "

    if [[ $REPLY =~ ^[0-3]$ ]]; then
        if [[ $REPLY == 1 ]]; then
            echo "Hostname: $HOSTNAME"
            echo 'uptime'
            sleep $DELAY
            continue
        fi
        if [[ $REPLY == 2 ]]; then
            df -h
            sleep $DELAY
            continue
        fi
        if [[ $REPLY == 3 ]]; then
            if [[ $(id -u) -eq 0 ]]; then
                echo "Home Space Utilization (All Users)"
                du -sh .
            else
                echo "Home Space Utilization ($USER)"
            fi
            sleep $DELAY
            continue
        fi
        if [[ $REPLY == 0 ]]; then
            break
        fi
    else
        echo "Invalid entry."
        sleep $DELAY
    fi
done
echo "Program terminated."
\end{lstlisting}

Для того чтобы избежать ошибок, связанных с некорректными подстановками, следует читаемые переменные оборачивать кавычками, т.е. вместо \verb|$REPLY| писать \verb|"$REPLY"|. Кавычки следует использовать не только для предохранения от пустых строк, но и в том случае, если переменная содержит строку с несколькими словами, например имя файла со встроенными пробелами.

\subsection{Трассировка}

Ошибки часто становятся причиной неожиданного направления выполнения сценария. То есть фрагменты сценария могут никогда не выполняться или выполняться в неправильном порядке или в неправильные моменты. Чтобы увидеть, как в действительности протекает выполнение программы, воспользуемся приемом \emph{трассировки}.

Один из способов трассировки заключается в размещении информативных сообщений в разных точках сценария, сообщающих, где протекает выполнение
\begin{lstlisting}[
style = bash,
numbers = none
] 
#!/bin/bash

dir_name="my_test_dir"

echo "Preparing to delete files" >&2
if [[ -d $dir_name ]]; then
    if cd $dir_name; then
        echo "Deleting files" >&2
        echo rm -f *
    else
        echo "Cannot cd to '$dir_name'" >&2
        exit 1
    fi
else
    echo "No such directory: '$dir_name'" >&2
    exit 1
fi
echo "File deletion complete" >&2
\end{lstlisting}

Здесь сообщения посылаются в стандартный поток вывода ошибок (\verb|>&2|), чтобы отделить их от обычного вывода. Кроме того отсутствуют отступы перед строками с сообщениями, -- это упростить их поиск, когда придет время убрать эти строки.

Кроме того, \texttt{bash} поддерживает встроенный метод трассировки, реализованный в виде параметра \texttt{-x}. Этот параметр можно добавить в первую строку сценария
\begin{lstlisting}[
numbers = none
]
#!/bin/bash -x
...
\end{lstlisting}

Включенный режим трассировки позволяют увидеть, какой вид приобретают команды после применения подстановки. Начальные знаки <<+>> помогают отличить трассировочную информацию от обычного вывода. Знак <<+>> -- это символ по умолчанию, используемый для вывода трассировки. Он хранится в переменной командной оболочки \texttt{PS4} (Prompt string 4 -- строка приглашения 4).

Можно изменить эту строку, добавив, например, номер выполняемой строки в сценарии. Здесь необходимо использовать одиночные кавычки -- это предотвращает подстановку до момента, когда строка приглашения не будет использоваться фактически
\begin{lstlisting}[
style = bash,
numbers = none
]
$ export PS4='$LINENO: '
$ ./del_dir_test.sh
# выведет
3: dir_name=my_test_dir
5: echo 'Preparing to delete files'
Preparing to delete files
6: [[ -d my_test_dir ]]
15: echo 'No such directory: '\''my_test_dir'\'''
No such directory: 'my_test_dir'
16: exit 1
\end{lstlisting}

Выполнить трассировку только выбранного фрагмента сценария можно с помощью конструкции \verb|set -x ... set +x|.

\subsection{Управление потоком выполнения с помощью case}

Командная оболочка \texttt{bash} поддерживает составную команду выбора из нескольких вариантов. Она имеет следующий синтаксис
\begin{lstlisting}[
style = bash,
numbers = none
]
case word in
    [pattern [| pattern]...) commands ;;]...
esac
\end{lstlisting}

Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

clear
echo "
Please Select:
1. Display System Information
2. Display Disk Space
3. Display Home Space Utilization
0. Quit
"
read -p "Enter select [0-3] > "

case $REPLY in
    0)	echo "Program terminated."
    exit
    ;;
    1)	echo "Hostname: $HOSTNAME"
    echo 'uptime'
    exit
    ;;
    2)	df -h
    ;;
    3)	if [[ $(id -u) -eq 0 ]]; then
            echo "Home Space Utilization (All Users)"
            du -sh .
        else
            echo "Home Space Utilization ($USER)"
        fi
        ;;
    *)	echo "Invalid entry" >&2
        exit 1
        ;;
esac
\end{lstlisting}

Команда \texttt{case} берет значение \emph{слова} -- в данном примере занчение переменной \texttt{REPLY} -- и затем сопоставляет его с указанными шаблонами. Найдя соответствие, она выполняет команды, связанные с найденными шаблоном. После нахождения соответствия сопоставление с нижележащими шаблонами уже не производится.

Примеры шаблонов:
\begin{itemize}
	\item \verb|a)| соответствует, если слово содержит \texttt{a},
	
	\item \verb|[[:alpha:]])| соответствует, если слово содержит единственный алфавитный символ,
	
	\item \verb|???)| соответствует, если слово содержит ровно три символа,
	
	\item \verb|*.txt)| соответствует, если слово заканчивается символами \texttt{.txt},
	
	\item \verb|*)| соответствует любому значению слова. Считается хорошей практикой включать этот шаблон в команду \texttt{case} последним, чтобы перехватывать любые значения слова, не соответствующие ни одному из предыдущих шаблонов, то есть чтобы перехватить любые недопустимые значения
\end{itemize}

Можно объединять шаблоны: \lstinline[basicstyle=\ttfamily\fontsize{10pt}{10pt}]{q|Q)}, что значит или \texttt{q} в нижнем регистре, или \texttt{Q} в верхнем регистре.

\subsection{Позиционные параметры}

К аргументам строки можно обращаться по номеру: \verb|$1, $2| etc. Даже в отсутствие аргументов переменная \verb|$0| всегда содержит первый элемент командной строки -- путь к файлу выполняемой программы.

\remark{%
В действительности, если использовать механизм подстановки параметров, можно получить доступ более чем к девяти параметрам. Чтобы указать число больше девяти, следует заключить его в фигурные скобки: например, \lstinline{$\{10\}}, \lstinline{$\{55\}} и т.д.
}

Командная оболочка поддерживает также переменную \verb|$#|, хранящую число аргументов командной строки.

Пример использования позиционных аргументов
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

PROGNAME=$(basename 0$)  # оставляет только имя файла, отрезая путь до файла

if [[ -e $1 ]]; then
    echo -e "\nFile Type: "
    file $1  # определяет тип файла
    echo -e "\nFile Status: "
    stat $1  # выводит информация по состоянию
else
    echo "$PROGNAME: usage: $PROGNAME file" >&2
    exit 1  # выход с ошибкой
fi
\end{lstlisting}

\subsection{Использование позиционных параметров в функциях}

Позиционные параметры используются для передачи аргументов не только в сценарии, но и в функции командной оболочки. Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

file_info () {
    if [[ -e $1 ]]; then
        echo -e "\nFile type: "
        file $1
        echo -e "\nFile status: "
        stat $1
    else
        echo "$FUNCNAME: usage: $FUNCNAME file" >&2
        return 1
    fi
}
# вызов функции
file_info ./read_file_gen.py
\end{lstlisting}

Благодаря этому появляется множество возможностей писать полезные функции для \verb|.bashrc|.

\subsection{Обработка позиционных аргументов скопом}

Иногда бывает необходимо выполнить операцию сразу со всеми позиционными параметрами. Например, может понадобиться написать обертку для некоторой программы, то есть сценарий или функцию, упрощающие запуск этой программы. Обертка принимает список непонятных для нее параметров командной строки и просто передает его обернутой программе.

Для этой цели командная оболочка предоставляет специальных параметра. Они оба замещаются полным списком позиционных параметров, но имеют некоторые тонкие отличия.

Специальные параметры:
\begin{itemize}
	\item \verb|$*|: замещается списком позиционных параметров, начиная с \verb|$1|. Если имя параметра \verb|$*| заключить в двойные кавычки, позиционные параметры будут перечислены в списке через первый символ в переменной IFS (по умолчанию пробел), а сам список будет размещен в одной строке и заключен в кавычки,
	
	\item \verb|$@|: замещается списком позиционных параметров, начиная с \verb|$1|. Если имя параметра \verb|$@| заключить в двойные кавычки, механизм подстановки заменит его списком позиционных параметров, заключенных в кавычки \emph{по отдельности}.
\end{itemize}

В большинстве ситуаций предпочтительнее использовать прием с \verb|"$@"|, потому что он сохраняет целостность каждого позиционного параметра.

Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

USER="Leor Finkelberg"
PROGNAME=$(basename $0)
TITLE="System Information Report For $HOSTNAME"
CURRENT_TIME=$(date +"%x %r %Z")
TIME_STAMP="Generated $CURRENT_TIME, by $USER"

report_uptime () {
    cat <<- _EOF_
        <H2>System Uptime</H2>
        <PRE>$(echo "uptime")</PRE>
        _EOF_
    return
}

report_disk_space () {
    cat <<- _EOF_
        <H2>Disk Space Utilization</H2>
        <PRE>$(df -h)</PRE>
        _EOF_
    return
}

report_home_space () {
    if [[ $(id -u) -eq 0 ]]; then
        cat <<- _EOF_
            <H2>Home Space Utilization (All Users)</H2>
            <PRE>$(du -sh .)</PRE>
            _EOF_
    else
        cat <<- _EOF_
            <H2>Home Space Utilization ($USER)</H2>
            <PRE>$(du -sh .)</PRE>
            _EOF_
    fi
    return
}

usage () {
    echo "$PROGNAME: usage: $PROGNAME [-f file | -i]" 
    return
}

write_html_page () {
    cat <<- _EOF_
        <HTML>
            <HEAD>
                <TITLE>$TITLE</TITLE>
            </HEAD>
            <BODY>
                <H1>$TITLE</H1>
                <P>$TIME_STAMP</P>
                $(report_uptime)      # подстановка того, что возвращает функция по POSIX
                $(report_disk_space)  # подстановка того, что возвращает функция по POSIX
                $(report_home_space)  # подстановка того, что возвращает функция по POSIX
            </BODY>
        </HTML>
        _EOF_
    return
}

interactive=
filename=

# цикл продолжается, пока позиционный параметр $1 не получит пустое значение
while [[ -n $1 ]]; do  # сейчас $1 это, например, -f
    case $1 in
        -f | --file)        shift  # теперь $2 становится $1
                            filename=$1  # здесь $1 это имя файла
                            ;;
        -i | --interactive) interactive=1
                            ;;
        -h | --help)        usage  # вызов функции
                            exit
                            ;;
        *)                  usage >&2
                            exit 1  # выход с ошибкой
                            ;;
    esac
    shift  # чтобы гарантировать завершение цикла
done

# интерактивный режим
if [[ -n $interactive ]]; then
    while true; do
        read -p "Enter name of output file: " filename 
        if [[ -e $filename ]]; then
            read -p "'$filename' exists. Overwrite? [y/n/q] > "
            case $REPLY in
                Y|y)    break
                        ;;
                Q|q)    echo "Program terminated."
                        exit
                        ;;
                *)      continue
                        ;;
            esac
        fi
        break  # если файл не существует, выбросить из цикла
    done
fi

if [[ -n $filename ]]; then
    if touch $filename && [[ -f $filename ]]; then
        write_html_page > $filename  # перенаправить вывод в заданный файл
    else
        echo "$PROGNAME: Cannot write file '$filename'" >&2
        exit 1
    fi
else
    write_html_page  # вывести в терминал
fi
\end{lstlisting}


\subsection{Цикл for}

Команду \texttt{for} удобно использовать в командной строке
\begin{lstlisting}[
style = bash,
numbers = none
]
$ for i in A B C D; do echo $i; done
# выведет
A
B
C
D
\end{lstlisting}

По-настоящему мощной особенностью \texttt{for} является разнообразие способов формирования списка слов. Например, можно использовать подстановку в фигурных скобках
\begin{lstlisting}[
style = bash,
numbers = none
]
$ for i in {A..D}; do echo $i; done
\end{lstlisting}

Или подстановку имен файлов
\begin{lstlisting}[
style = bash,
numbers = none
]
$ for i in read*.sh; do echo $i; done
# выведет
read-ifs.sh
read-integer.sh
read-multiple.sh
read-secret.sh
read-validate.sh
\end{lstlisting}
или подстановку команд
\begin{lstlisting}[
style = bash,
numbers = none
]
...
for file in $(ls); do
    printf "File: %s;\t\tCount: %s\n" $file $(echo $file | wc -c)
done
\end{lstlisting}

Здесь \verb|$(ls)| возвращает список файлов, по которому можно <<пробежаться>> переменной цикла \texttt{file}. 

Если необязательный компонент \emph{коллекции} в команде \texttt{for} отсутствует, она по умолчанию обрабатывает позиционные аргументы, переданные при вызове сценария
\begin{lstlisting}[
style = bash,
title = {\sffamily simple\_for.sh},
numbers = none
]
#!/bin/bash

# здесь переменная цикла file поочередно принимает имена файлов, переданные при вызове сценария
for file; do
    if [[ -e $file ]]; then  # если файл существует, то ...
        line=$(grep -inE 'done' $file)
        echo $line
    fi
done
\end{lstlisting}

Этот сценарий можно было бы вызвать так
\begin{lstlisting}[
style = bash,
numbers = none
]
$ ./simple_for.sh file_name1.txt file_name2.txt
\end{lstlisting}

\subsection{Цикл for в стиле языка C}

Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

for (( i=0; i<5; i+=1 )); do
    echo $i
done
\end{lstlisting}

Здесь \verb|i=0| инициализирует переменную, \verb|i<5| указывает условие останова и \verb|i=i+1| обеспечивает изменчивость переменной.

\subsection{Подстановка параметров}

Некоторые формы подстановки параметров помогают решать проблемы с несуществующими, или пустыми, переменными: \verb|${parameter:-default_value}|. Если параметр неопределен (то есть отсутствует) или содержит пустое значение, механизм подстановки вернет значение указанного слова. Если параметр непустой, механизм подстановки вернет значение параметра
\begin{lstlisting}[
style = bash,
numbers = none
]
$ foo=  # пустое значение
$ echo ${foo:-"default_value"}  # default_value
$ foo=bar
$ echo ${foo:-"default_value"}  # bar
\end{lstlisting}

Вот еще один вариант подстановки, где вместо дефиса используется знак <<\texttt{=}>>: \verb|${parameter:=value}|. Если параметр не определен или содержит пустое значение, механизм подстановки вернет значение указанного слова и дополнительно присвоит его параметру. Если параметр непустой, механизм подстановки вернет значение параметра
\begin{lstlisting}[
style = bash,
numbers = none
]
$ foo=
$ echo ${foo:="value"}  # value
$ foo=bar
$ echo ${foo:="value"}  # bar
$ echo $foo  # bar
\end{lstlisting}

\subsection{Получение имен переменных}

Командная оболочка может возвращать \emph{имена переменных}: \verb|${!prefix*}|, \verb|${!prefix@}|. Эти две формы подстановки возвращают имена существующих переменных, начинающиеся с указанного префикса. Согласно документации \texttt{bash}, обе формы работают совершенно одинаково. 

Следующая команда выводит список всех переменных окружения с именами, начинающимися с \texttt{BASH}
\begin{lstlisting}[
style = bash,
numbers = none
]
$ echo ${!BASH*}  # BASH BASHOPTS BASHPID BASH_ALIASES BASH_ARGC...
$ echo ${!USER*}  # USERDOMAIN USERNAME USERPROFILE
\end{lstlisting}

\subsection{Операции со строками}

Существует множество форм подстановки, которые можно использовать для работы со строками. Многие из них хорошо подходят для операций с путями. Форма \verb|${#parameter}| вернет длину строки, содержащуюся в указанном параметре. Обычно роль параметра играет строка, но если передать \verb|@| или \verb|*|, то механизм подстановки вернет число позиционных параметров
\begin{lstlisting}[
style = bash,
numbers = none
]
$ foo="This string is long."
$ echo "'$foo' is ${#foo} character long."  # 'This string is long.' is 20 characters long.
\end{lstlisting}

Следующая форма подстановки
\begin{lstlisting}[
style = bash,
numbers = none
]
${parameter:shift}
${parameter:shift:length}
\end{lstlisting}
используется для извлечения фрагмента строки, содержащейся в параметре. Извлечение начинается с указанного смещения от начала строки и продолжается до конца строки, если не указано длина.

Если указать отрицательное число, его отсчет начнется с конца строки вместо начала. Обратите внимание, что отрицательному значению должен предшествовать пробел, чтобы предотвратить путаницу с формой \verb|${parameter:-value}|. 

Следующие две формы
\begin{lstlisting}[
numbers = none
]
${parameter#pattern}
${parameter##pattern}
\end{lstlisting}
возвращают значение параметра, удаляя из него начальную часть, определяемую указанным шаблоном. В шаблоне допускается использовать групповые символы: например, те, что используются в подстановке путей. Эти две формы отличаются тем, что форма \verb|#| удаляет кратчайшее совпадение, тогда как форма \verb|##| удаляет самое длинное совпадение
\begin{lstlisting}[
numbers = none
]
$ foo="file.tar.gz"
$ echo ${foo#*\.}  # tar.gz
$ echo ${foo##*\.}  # gz
\end{lstlisting}

Следующие две формы
\begin{lstlisting}[
numbers = none
]
${parameter%pattern}
${parameter%%pattern}
\end{lstlisting}
действуют так же, как формы \verb|#| и \verb|##|, представленные выше, но удаляют текст с конца строки, содержащейся в параметре
\begin{lstlisting}[
numbers = none
]
$ foo="file.tar.gz"
$ echo ${foo%\.*}  # file.tar
$ echo ${foo%%\.*}  # file
\end{lstlisting}

Следующие формы
\begin{lstlisting}[
numbers = none
]
${parameter/pattern/string}
${parameter//pattern/string}
${parameter/#pattern/string}
${parameter/%pattern/string}
\end{lstlisting}
выполняют поиск с заменой в содержимом указанного параметра. Если в параметре будет найдено совпадение с шаблоном, который может содержать групповые символы, это совпадение будет заменено содержимым указанной строки. Первая форма заменит только первое совпадение с шаблоном. Форма \verb|//| заменит все найденные совпадения. Форма \verb|/#| выполняет замену, только если совпадение с шаблоном найдено в самом начале строки, а формы \verb|/%| выполняет замену, только если совпадение найдено в конце строки. Часть \verb|/string| можно опустить, и тогда совпавший фрагмент будет удален.

Пример
\begin{lstlisting}[
numbers = none
]
#!/bin/bash

for i; do
    if [[ -r $i ]]; then
        max_word=
        max_len=
        for j in $(strings $i); do
            len=${#j}  # <<---
            if (( len > max_len )); then
                max_len=$len
                max_word=$j
            fi
            ...
\end{lstlisting}

Если, к пример, требуется убрать нули в начале имени файла, то
\begin{lstlisting}[
numbers = none
]
$ file="00test_file.txt"
$ echo ${file/#00}  # test_file.txt
\end{lstlisting}

Пример использования составного оператора (\verb|++|)
\begin{lstlisting}[
numbers = none
]
for ((i=0; i<=20; ++i)); do
    if [[ $((i % 5)) -eq 0 ]]; then
        printf "<%d> " $i
    else
        printf "%d " $i
    fi
done
\end{lstlisting}

Бывает полезным тернарный оператор
\begin{lstlisting}[
style = bash,
numbers = none
]
$ a=0
$ echo $((a<1?++a:--a))  # 1
$ echo $((a<1?++a:--a))  # 0
\end{lstlisting}

Обратите внимание, что прямое присваивание в этом операторе считается недопустимой операцией. Эту проблему можно решить, заключив выражения присваивания в круглые скобки
\begin{lstlisting}[
style = bash,
numbers = none
]
$ a=0
$ echo $(( a<1?(a+=1):(a-=1) ))
\end{lstlisting}

\subsection{Массивы}

Значения элементам массивов можно присваивать одним из двух способов. Присваивание одиночных значений осуществляется с использованием следующего синтаксиса
\begin{lstlisting}[
style = bash,
numbers = none
]
name[index]=value
\end{lstlisting}

Присвоить сразу несколько значений можно с использованием следующего синтаксиса
\begin{lstlisting}[
style = bash,
numbers = none
]
name=(value1 value2 ...)
\end{lstlisting}

Обратиться к элементу массива можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
$ echo ${array[4]}
\end{lstlisting}

Вывести содержимое всего массива можно, используя индексы \verb|*| и \verb|@|
\begin{lstlisting}[
style = bash,
numbers = none
]
$ read -r -a words <<< "This is a simple string."
$ echo ${words[*]}  # This is a simple string.
$ echo ${words[@]}  # This is a simple string.
\end{lstlisting}

Для того чтобы вывести массив по элементам, разделенным не по пробелам по кавычкам, следует воспользоваться конструкцией
\begin{lstlisting}[
style = bash,
numbers = none
]
$ animals=("a dog" "a cat" "a fish")
$ for i in "${animals[@]}"; do
>    echo $i
>done
# выведет
a dog
a cat
a fish
\end{lstlisting}

В общем случае конструкция \verb|"${array[@]}"| гораздо полезнее.

Определить число элементов в массиве можно так
\begin{lstlisting}[
numbers = none
]
$ cae_packages=("Ansys MAPDL" "Nastran" "Abaqus")
$ echo ${#cae_packages[@]}  # 3
\end{lstlisting}

Удалить массив можно командой \texttt{unset}
\begin{lstlisting}[
style = bash,
numbers = none
]
$ unset cae_packages  # удалить массив
$ unset 'cae_packages[2]'  # удалить один элемент
\end{lstlisting}

При удалении одного элемента массива нужно элемент массива заключить в кавычки, чтобы предотвратить подстановку путей оболочки.

\subsection{Группы команд и подоболочки}

Группы команд оформляются с помощью \verb|{...}|, а подоболочки -- с помощью \verb|(...)|. Все команды, входящие в группу, выполняются в текущей оболочке, подоболочка (как можно догадаться из названия) выполняет свои команды в дочерней копии текущей командной оболочке. Это означает, что в момент запуска подоболочки создается \emph{копия текущей оболочки} и передается новому экземпляру оболочки. Когда подоболочка завершается, ее копия окружения уничтожается, соответственно теряются любые изменения в окружении подоболочки (включая значения переменных).

Поэтому если нет прямой необходимости в использовании подоболочки, предпочтительнее использовать \emph{группы команд}. Группы команд выполняются быстрее и требуют меньше памяти.

\remark{%
Конвейеры команд всегда выполняются в \emph{подоболочке}!
}

Командная оболочка поддерживает экзотическую форму подстановки, которая называется \emph{подстановкой процессов}. Подстановка процессов оформляется двумя способами: для процессов, отправляющих результаты в \emph{стандартный вывод}
\begin{lstlisting}[
style = bash,
numbers = none
]
<(list)
\end{lstlisting}
и для процессов, принимающих данные через стандартный ввод
\begin{lstlisting}[
style = bash,
numbers = none
]
>(list)
\end{lstlisting}

Подстановка процессов позволяет интерпретировать вывод подоболочки как обычный файл и осуществлять его перенаправление. Так как это форма подстановки, всегда можно узнать действительное подставляемое значение
\begin{lstlisting}[
style = bash,
numbers = none
]
$ echo <(echo "foo")  # /dev/fd/63
\end{lstlisting}

\subsection{Ловушки}

В больших и сложных программах процедура обработки сигналов может оказаться весьма кстати. Проектируя большие сценарии, важно предусмотреть их реакцию на неожиданный выход пользователя из системы или выключение компьютера во время их выполнения. Программы, представляющие эти процессы, могут выполнять некие действия, гарантирующие корректное завершение с сохранением необходимых данных.

Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

# ловушка, которая реагирует на 
trap "echo 'I am ignoring you.'" SIGINT SIGTERM

for i in {1..5}; do
    echo "Iteration $i of 5"
    sleep 5
done
\end{lstlisting}

Этот сценарий определяет ловушку, которая будет выполнять команду \texttt{echo} в ответ на сигналы \texttt{SIGINT} и \texttt{SIGTERM}, получаемые сценарием во время выполнения.

При попытке прервать работу программы в терминал будет выводится сообщение <<\texttt{I am ignoring you.}>>.

Иногда бывает непросто сформировать строку с требуемой последовательностью команд, поэтому на практике в качестве команды часто использует функции. Следующий пример демонстрирует применение разных функций для обработки разных сигналов
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

exit_on_signal_SIGINT () {
    echo "Script interrupted." 2>&1
    exit 0  # << для того чтобы прекратить выполнение программы!
}

exit_on_signal_SIGTERM () {
    echo "Script terminated." 2>&1
    exit 0  # << для того чтобы прекратить выполнение программы!
}

# ловушки
trap exit_on_signal_SIGINT SIGINT
trap exit_on_signal_SIGTERM SIGTERM

for i in {1..5}; do
    echo "Iteration $i of 5"
    sleep 5
done
\end{lstlisting}

Здесь в каждой ловушке используется своя функция, которая будет вызвана для обработки конкретного сигнала. Обратите внимание на включение команды \texttt{exit} в обе функции обработки сигналов. Без этого сценарий продолжил бы выполняться после завершения функция.

\section{Язык обработки шаблонов awk. Базовые концепции}

Программа на \texttt{awk} (программа, набранная в командной строке или в файле программы) состоит из одной и более строк, в которых содержится \emph{шаблон} и/или \emph{действие} в следующем формате: \verb|шаблон { действие }|.

Шаблон выбирает строки из ввода. Утилита \texttt{awk} выполняет действие над всеми строками, выбранными шаблоном. Фигурные скобки, в которые заключено действие, позволяют \texttt{awk} отличить его от шаблона.

Если программная строка не содержит шаблона, \texttt{awk} выбирает из ввода все строки. Если программная строка не содержит действия, \texttt{awk} копирует выбранные строки на стандартный вывод.

Два уникальных шаблона, \texttt{BEGIN} и \texttt{END}, выполняют команды перед тем, как утилита \texttt{awk} приступит к обработке ввода, и после того, как она завершит эту обработку. До начала обработки всего ввода утилита \texttt{awk} выполняет \emph{действия}, связанные с шаблоном \texttt{BEGIN}, а по окончании обработки -- \emph{действия}, связанные с шаблоном \texttt{END}.

\texttt{awk} поддерживает несколько специальных переменных (\texttt{FILENAME}, \texttt{NR}, \texttt{FS}, \texttt{NF} и пр.). Рассмотрим для примера переменную \texttt{NR}, смысл которой зависит от контекста: если переменная \texttt{NR} используется в контексте обычного действия, то она содержит номер записи (строки), принадлежащей текущей строке. Однако, если эта переменная используется в контексте шаблона \texttt{END}, то она связывается с номером последней строки.

Значение разделителей полей в выводе можно изменить, присвоив его значение переменной \texttt{OFS}
\begin{lstlisting}[
style = bash,
numbers = none
]
$ cat ofs_demo
BEGIN { OFS = "\t" }
    {
    if ($1 ~ /ply/) $1 = "plymouth"
    if ($1 ~ /chev/) $1 = "chevrolet"
    print
    }
$ awk -f ofs_demo file_name.txt
\end{lstlisting}

Пример использования конструкций \texttt{BEGIN}, \texttt{END} и \texttt{printf}
\begin{lstlisting}[
style = bash,
numbers = none
]
awk -F ',' 'BEGIN { print "### PROGRAM ###" } { sum += $3 } END { printf "result=%s", sum }' ram_price.csv
\end{lstlisting}

Здесь печатается строка <<\verb|### PROGRAM ###|>>, потому что она связана с \emph{шаблоном} \texttt{BEGIN}. Затем вычисляется сумма 3-его столбца и наконец выполняется строка <<\verb|result=%s|>>, так как она связана с \emph{шаблоном} \texttt{END}.



\section{Вспомогательные конструкции \texttt{Vim}}

\subsection{Регистры \texttt{Vim}}

Регистры \texttt{Vim} -- это всего лишь контейнеры для хранения текста. Их можно использовать как своеобразные буферы обмена копируя текст в регистры и вставляя его из регистров, или для записи макросов, сохраняя в них последовательности нажатий на клавиши.

\subsection{Макросы}

Клавиша \texttt{q} действует как своеобразная кнопка <<Запись>> и одновременно как кнопкаа <<Стоп>>. Чтобы начать запись последовательности нажатий на клавиши, необходимо ввести \verb|q{register}|, указав имя регистра, где будет сохранен макрос. 

Посмотреть содержимое регистра \verb|"a| можно с помощью \texttt{:reg}
\begin{lstlisting}[
language = cmd,
numbers = none
]
:reg a
\end{lstlisting}

Команда \verb|@{register}| служит для выполнения содержимого указанного регистра. То есть, если макрос записывался в регистр \verb|"a|, то вызывать нужно макрос из того регистра как \verb|@a|.

Макрос записанный, например в регистр \texttt{"a}, можно выполнить заданное число раз, указав число повторений, например так \verb|25@a|.

Если требуется, чтобы макрос выполнялся для каждой строки из заданного диапазона, то следует использовать команду \texttt{:normal}\footnote{Восклицательный знак для игноирования пользовательских настроек}
\begin{lstlisting}[
language = cmd,
numbers = none
]
:normal! 25@a
\end{lstlisting}



\subsection{Базовые концептуальные конструкции}

Перейти в ВИЗУАЛЬНЫЙ режим, выделить 2 <<слова>> (фрагмент текста) и скопировать в безымянный регистр (\verb|""|)
\begin{lstlisting}[
language = cmd,
numbers = none
]
v2wy
\end{lstlisting}

Вставить данные из регистра (именованного, неименованного и др.), не покидая режима вставки, можно с помощью сочетания клавиш \verb|<C-r>{registr}| (т.е. \texttt{Ctrl+C} и имя регистра). Пусть в \emph{регистре выделенного фрагмента} (\texttt{"*}) хранится какая-нибудь строка. С помощью команды \texttt{A} переходим в режим ВСТАВКИ в конец строки. Теперь строку и регистра можно вставить сочетанием \verb|<C-r>|. После этого под курсором появится символ \verb|"|. Клавиша \texttt{*} заменит символ \verb|"| содержимым регистра \verb|"*|.

\emph{Фрагмент} строки можно вставить слева от курсора с помощью команды \texttt{P} или справа от курсора с помощью команды \texttt{p}.

Если же копировалась строка \emph{целиком}, то команда \texttt{p} вставляет строку под текущей, а команда \texttt{P} -- над текущей.

Удалить слово, находясь внутри слова (т.е. на любой позиции в пределах слова), можно так
\begin{lstlisting}[
language = cmd,
numbers = none
]
diw
\end{lstlisting}

Аналогично можно удалить слово и перейти в режим ВСТАВКИ, находясь внутри слова
\begin{lstlisting}[
language = cmd,
numbers = none
]
ciw
\end{lstlisting}

Используя подобную конструкцию, можно удалить текст, заключенный в кавычки, и тут же перейти в режим ВСТАВКИ
\begin{lstlisting}[
language = cmd,
numbers = none
]
ci"
\end{lstlisting}

Захватить текущее слово в регистр \texttt{"a}
\begin{lstlisting}[
language = cmd,
numbers = none
]
"ayiw
\end{lstlisting}

Вырезать текущую строку в регистр \texttt{"b}
\begin{lstlisting}[
language = cmd,
numbers = none
]
"bdd
\end{lstlisting}

Захватить последовательность символов, заключенную в кавычки, в регистр \texttt{"b}
\begin{lstlisting}[
language = cmd,
numbers = none
]
"byi'
\end{lstlisting}

Захватить слово в неименованный регистр (\verb|""|)
\begin{lstlisting}[
language = cmd,
numbers = none
]
""yiw
\end{lstlisting}

Захватить последовательность символов от текущего положения курсора до конца строки в \emph{регистр захвата} (\texttt{"0}). Все что копируется с помощью \texttt{y} попадает в регистр захвата
\begin{lstlisting}[
language = cmd,
numbers = none
]
y$
\end{lstlisting}

Вставить данные из регистра захвата
\begin{lstlisting}[
language = cmd,
numbers = none
]
"0p
\end{lstlisting}

Захватить в \emph{регистр выделенного фрагмента} (\texttt{"*}) несколько слов
\begin{lstlisting}[
language = cmd,
numbers = none
]
v3wey
\end{lstlisting}


Вставить данные из именованного регистра \texttt{b}
\begin{lstlisting}[
language = cmd,
numbers = none
]
"bp	
\end{lstlisting}

Открыть файл на заданной строке
\begin{lstlisting}[
language = cmd,
numbers = none
]
$ vim +10 file_name.txt
\end{lstlisting}

Открыть файл и найти заданный шаблон
\begin{lstlisting}[
language = cmd,
numbers = none
]
$ vim +/pattern file_name.txt
\end{lstlisting}

Выполнить одну или несколько команд редактора \texttt{ex} при старте можно с помощью опции \verb|-c| (\texttt{Vim} принимает до 10 штук). 

Например, чтобы скопировать несколько строк из файла в буфер, а затем закрыть можно использовать ключ \verb|-c| несколько раз
\begin{lstlisting}[
language = cmd,
numbers = none
]
$ vim -c %y -c q file_name.py
\end{lstlisting}

Запустить \texttt{Vim}, открыв два файла, с вертикальным разбиением
\begin{lstlisting}[
language = cmd,
numbers = none
]
$ vim -O2 file_name1.txt file_name2.txt
\end{lstlisting}


\section{Обновление версии Git на Centos 7}

По умолчанию на Cetnos 7 стоит Git 1.8.X. Для того чтобы обновить Git нужно просто запустить следующий сценарий
\begin{lstlisting}[
title = {\sffamily gitupgrade.sh},
style = bash,
numbers = none
]
#!/bin/bash
yum -y remove git
yum -y clean packages
mkdir tempgit
cd tempgit
yum install -y autoconf cpio curl-devel expat-devel gcc gettext-devel make
openssl-devel perl-ExtUtils-MakeMaker zlib-devel
wget -O v2.24.1.tar.gz https://github.com/git/git/archive/v2.24.1.tar.gz
tar -xzvf ./v2.24.1.tar.gz
cd git-2.24.1/
make configure
./configure --prefix=/usr/local/git
make && make install
ln -sf /usr/local/git/bin/* /usr/bin/
cd ..
rm -fr git-2.24.1
cd ..
rm -fr tempgit
echo "results"
which git
git --version
\end{lstlisting}
как
\begin{lstlisting}[
style = bash,
numbers = none
]
$ chmod +x gitupgrade.sh
$ sudo ./gitupgrade.sh
\end{lstlisting}

\section{Полезные конструкции оболочки \texttt{bash}}

Найти в корневом каталоге и всех подкатлогах (\texttt{/}), обычные файлы (\texttt{-type f}), измененные за последний день (\texttt{-mtime -l}), за исключением тех файлов, у которых есть суффикс \texttt{.o} (\texttt{! -name '*.o'})

\begin{lstlisting}[
language = cmd,
numbers = none
]
find / -type f -mtime -l ! -name '*.o'
\end{lstlisting}

Вывести список поддиректорий (\texttt{-type d}) текущей директории (\texttt{.}), в именах которых встречается подстрока \texttt{'cheat'}, без учета регистра (\texttt{-iname})

\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -type d -iname 'cheat*'
\end{lstlisting}

Вывод имен файлов и удаление файлов с именами \texttt{core} или \texttt{junk} из рабочего каталога и всех его подкаталогов (круглые скобки обязательно отделяются пробелами)

\begin{lstlisting}[
language = cmd,
numbers = none
]
find . \( -name core -o -name junk \) -print -exec rm {} \;
\end{lstlisting}

Скопировать все \texttt{csv}-файлы из родительской директории (\texttt{..}) в текущую (\texttt{.})

\begin{lstlisting}[
language = cmd,
numbers = none
]
cp -ip ../*.csv
\end{lstlisting}

Скопировать файл из родительской директории в текущую директорию

\begin{lstlisting}[
language = cmd,
numbers = none
]
cp -ip ../Cheat_sheet_Git/cheat_sheet_git.tex .
\end{lstlisting}

Скопировать одну директорию в другую

\begin{lstlisting}[
language = cmd,
numbers = none
]
cp -rip ../Cheat_sheet_Git/style_packages/ .
\end{lstlisting}

Переименовать файл

\begin{lstlisting}[
language = cmd,
numbers = none
]
mv cheat_sheet_git.tex cheat_sheet_bash.tex
\end{lstlisting}

Найти все файлы с расширением \texttt{*.csv} и выбрать из них те, в которых содержится строка \texttt{'state'} (для каждого файла, отвечающего поисковому шаблону, запускается свой процесс)

\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -name '*.csv' -exec grep -niE 'state' {} \;
\end{lstlisting}

Вывести список файлов из текущей директории и всех поддиректорий

\begin{lstlisting}[
language = cmd,
numbers = none
]
ls -l *
\end{lstlisting}

Найти среди файлов с расширением \texttt{*.py} те, в именах которых есть подстрока \texttt{'spark'} (используется конвейер)

\begin{lstlisting}[
language = cmd,
numbers = none
]
ls -l *.py | grep -iE 'spark'
\end{lstlisting}

Найти файлы с расширением \texttt{*.py} и к каждому из них применить команду \texttt{grep}, которая будет искать в файле подстроку \texttt{'argparse'} без учета регистра, с выводом номера строки, на которой она нашла искомую строку по регулярному выражению \texttt{'argparse'} (работает {\color{deepred} медленно}, так как для каждого файла, отвечающего поисковому шаблону, запускается свой процесс)

\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -maxdepth 1 -name '*.py' -exec grep -inE 'argparse' {} \;
\end{lstlisting}

Альтернативный вариант с использованием \texttt{xargs} (работает значительно быстрее варианта с \texttt{-exec}). Команда \texttt{xargs} превращает стандартный ввод в командные строки, интерпретируя каждое строковое значение, отделенное пробельными символами в качестве отдельного аргумента. Затем она создает командную строку из команды и ряда аргументов. Когда командная строка при добавлении еще одного аргумента достигает максимально возможной длины, \texttt{xargs} запускает созданную командную строку. Если ввод продолжается, \texttt{xargs} повторяет процесс построения командной строки и ее запуска. Этот процесс продолжается до тех пор, пока не будет прочитан весь ввод

\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -maxdepth 1 -name '*.py' | xargs grep -inE 'argparse'
\end{lstlisting} 

Для того чтобы увидеть как \texttt{xargs} строит командую строку, можно добавить флаг \texttt{-p} (интерактивный режим), например,
\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -name '*.py' | xargs -p grep bash
\end{lstlisting} 

Найти в файлах с расширением \texttt{*.tex} строку \texttt{'section'} без учета регистра и вывести три строки контекста
\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -name '*.tex' | xargs grep -iE 'section' -3
\end{lstlisting}

Вывести список пакетов, в именах которых встречается подстрока \texttt{'python'} с контекстом \texttt{'sql'}
\begin{lstlisting}[
language = cmd,
numbers = none
]
conda list | grep -inE 'python.*sql'
\end{lstlisting}

Получить информацию о доступном метсе на диске
\begin{lstlisting}[
language = cmd,
numbers = none
]
df -h
\end{lstlisting}

Скачать файл с тем же именем, что на удаленном репозитории 
\begin{lstlisting}[
language = cmd,
numbers = none
]
curl -O http://merionet.ru/yourfile.tar.gz
\end{lstlisting}

Передать json-файл веб-сервису (путь до файла данных должен начинаться с символа \verb|@|)
\begin{lstlisting}[
style = bash,
numbers = none
]
curl -X POST "Content-Type: application/json" --data "@file_name.json" "localhost:5000/api/solver/balance"
\end{lstlisting}

Скачать файл с удаленного репозитория с новым именем и/или путем
\begin{lstlisting}[
language = cmd,
numbers = none
]
curl -o newfile.tar.gz http:// merionet.ru /yourfile.tar.gz
\end{lstlisting}

Возобновить прерванную загрузку с того места, где она остановилась
\begin{lstlisting}[
language = cmd,
numbers = none
]
curl -C - -O http://merionet.ru/yourfile.tar.gz
\end{lstlisting}

Скачать несколько файлов 
\begin{lstlisting}[
language = cmd,
numbers = none
]
curl -O http://merionet.ru/info.html -O http://wiki.merionet.ru/about.html
\end{lstlisting}

Вывести имена пакетов, имеющих отношение к \texttt{Python}. Ключ \verb|-n| для подавления автоматического вывода всех строк
\begin{lstlisting}[
language = cmd,
numbers = none
]
conda list | sed -n '/python/p' 
\end{lstlisting}

Вывести первые десять строк из списка пакетов, который возвращает \texttt{conda}
\begin{lstlisting}[
language = cmd,
numbers = none
]
conda list python | sed -n '1,10p'
\end{lstlisting}

Заменить в сообщении фиксации \texttt{git} <<Python>> на <<Fortran>>
\begin{lstlisting}[
language = cmd,
numbers = none
]
git show -s HEAD | sed '1,$s/Python/Fortran/g'
\end{lstlisting}

Удалить строки в сообщении фиксации, начиная с первой и до первой пустой строки (\verb|/^$|)
\begin{lstlisting}[
language = cmd,
numbers = none
]
git show -s HEAD | sed '1,/^$/d'
\end{lstlisting}

Заменить в сообщении фиксации \texttt{git} <<PostgreSQL>> на <<MySQL>> и результат записать в файл
\begin{lstlisting}[
language = cmd,
numbers = none
]
git show -s HEAD~2 | sed '1,$s/cookiecutter/somthingelse/g' > output.txt
\end{lstlisting}




\subsection{Переадресация ввода-вывода}

Перенаправить \emph{стандартный поток вывода} данных (дескриптор файла 1) и \emph{стандартный поток вывода ошибок} (дескриптор файла 2), которые возвращает \texttt{conda} с захватом всех пакетов, в именах которых встречается подстрока \texttt{'python'}, в файл с именем \texttt{test\_file.log} (временный поток вывода данных \texttt{\&1}). Если команда вернет ошибку, то сообщение ошибки перепишет содержимое файла \texttt{test\_file.log}
\begin{lstlisting}[
language = cmd,
numbers = none
]
conda list | grep -inE 'python' > test_file.log 2>&1
\end{lstlisting}

Более короткий вариант рассмотренной выше конструкции
\begin{lstlisting}[
language = cmd,
numbers = none
]
conda list | grep -inE 'python' &> test_file.log
\end{lstlisting}

Присоединить стандартный поток вывода данных и стандартный поток вывода ошибок к содержимому файла. Конструкция \texttt{rm df} возвращает сообщение об ошибке <<\texttt{rm: cannot remove 'df': No such file or directory}>>, которое можно добавить в файл
\begin{lstlisting}[
language = cmd,
numbers = none
]
rm df &>> test_file.txt
\end{lstlisting}

Найти в текущей директории файлы с расширением \texttt{.tex}, в именах которых встречается подстрока <<\texttt{bash}>>, перенаправить эти файлы утилите \texttt{grep}, которая будет искать в теле файлов строки, в которых встречается подстрока <<\texttt{vim}>>, причем стандартный поток вывода ошибок перенаправляется в <<черную дыру>>
\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -name '*bash*.tex' | xargs grep -inE 'vim' 2>/dev/null
\end{lstlisting}

Записать строку в файл и дополнительно вывести строку в терминал
\begin{lstlisting}[
style = bash,
numbers = none
]
echo 'test string' | tee ./logfile.txt
\end{lstlisting}

Использовать информацию из <<безымянного файла>>, созданного в терминале с помощью heredoc; прочитает содержимое безымянного файла, запустит утилиту \texttt{psql} и выведет результат ее работы
\begin{lstlisting}[
style = bash,
numbers = none	
]
cat << EOF | psql -U postgres -p 5433 -d demo -f -
  TABLE tickets LIMIT 5;
EOF
\end{lstlisting}
или так
\begin{lstlisting}[
style = bash,
numbers = none
]
echo "TABLE tickets LIMIT 5;" | psql -U postgres -p 5433 -d demo -f -
\end{lstlisting}

Выполнить Python-сценарий без создания файла
\begin{lstlisting}[
style = bash,
numbers = none
]
cat << EOF | ptpython
import math
print(math.exp(3))
EOF
\end{lstlisting}

Еще может быть полезна связка <<\texttt{cat} - \texttt{EOF}>> с перенаправлением
\begin{lstlisting}[
style = bash,
numbers = none	
]
cat << EOF > output.txt | tee
test message!
EOF
\end{lstlisting}
Здесь строки, принадлежащие блоку \texttt{EOF}, будут переданы команде \texttt{cat}, которая перенаправит вывод в файл \texttt{output.txt} и на команду \texttt{tee}, которая в свою очередь перенаправит вывод в стандартный поток вывода (то есть в окно терминала).

Получить свой внешний IP-адрес
\begin{lstlisting}[
style = bash,
numbers = none	
]
curl ifconfig.me
\end{lstlisting}

Получить прогноз погоды
\begin{lstlisting}[
style = bash,
numbers = none	
]
curl wttr.in/Moscow
\end{lstlisting}

Если требуется выполнить какую-то команду в другой директории, не покидая текущую, следует просто обернуть эту команду круглыми скобами, которые запустят \emph{подоболочку} (subshell) и выполнят в ней заданную команду
\begin{lstlisting}[
style = bash,
numbers = none	
]
(cd /tmp && ls -l)
\end{lstlisting}


\subsection{Информация об использовании дискового пространства}

Вывести размер директорий в Мегабайтах (\texttt{M})
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -BM
\end{lstlisting}

Вывести итоговый размер директории (\texttt{c}) в Мегабайтах (\texttt{M})
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -cBM
\end{lstlisting}

Перевести размеры директорий в понятный человеку формат
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -h
\end{lstlisting}

Вывести информацию об указанной директории в дружественном формате
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -sh style_packages/
\end{lstlisting}

Вывести размер папок текущей директории, не погружаясь глубже корневых папок
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -h -d 1
\end{lstlisting}
или так
\begin{lstlisting}[
language = cmd,
numbers = none
]
du --max-depth=1 -h
\end{lstlisting}

Вывести информацию об использовании дискового пространства иерархией каталога с подсчетом общего размера каталога и перенаправлением стандартного потока вывода ошибок в <<черную дыру>>
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -ch -d 1 2>/dev/null
\end{lstlisting}

\subsection{Информация о файлах и операциях}

Чтобы узнать используется в файле табуляция или нет достаточно прочитать его в терминал командой \texttt{cat} с ключом \verb|-A|. Символ табуляции в тексте будет представлен парой символов \verb|^I| (что означает <<Ctrl+I>>). К слову, символ \verb|$| отмечает истинный конец строки, помогая увидеть дополнительные пробелы в конце строки
\begin{lstlisting}[
style = bash,
numbers = none
]
cat -A file_name.txt
\end{lstlisting}

Вывести список удаляемых файлов
\begin{lstlisting}[
style = bash,
numbers = none
]
$ echo rm -f *.txt
\end{lstlisting}

Вывести час создания файла
\begin{lstlisting}[
style = bash,
numbers = none
]
$ stat -c %y file_name.txt | cut -c 12-13  # 17
\end{lstlisting}

\subsection{Управление выводом}

Вывести элементы 3-его столбца, значения которых превышают 1000000
\begin{lstlisting}[
style = bash,
numbers = none
]
awk -F ',' '{ if ($3 < 1000000) print $3 }' file_name.csv
\end{lstlisting}

Прочитать только те строки из файла, которые имеют отношение к <<python>>
\begin{lstlisting}[
style = bash,
numbers = none
]
awk '/python/' file_name.txt
\end{lstlisting}

Прочитать только те строки, которые отвечают заданному шаблону, и вывести 1-ый и 2-ой столбцы
\begin{lstlisting}[
style = bash,
numbers = none
]
awk '/python/ { print $1, $3 }' file_name.txt
\end{lstlisting}

Вывести только те строки, которые начинаются с подстроки <<ipy>>
\begin{lstlisting}[
style = bash,
numbers = none
]
awk '$1 ~ /^ipy/' file_name.txt
\end{lstlisting}

Вывести только строки полей с номерами 4 и 5; при этом нужно вывести только те строки, в которых 4-ое поле начинается с <<"Ham>>
\begin{lstlisting}[
style = bash,
numbers = none
]
awk -F',' '$4 ~ /^"Ham/ { print $4, $5 }' titanic_train.csv
\end{lstlisting}

Вывести только те строки, значения которых во 2-ом поле равны 1; напечатать 4-ый и 5-ый столбцы
\begin{lstlisting}[
style = bash,
numbers = none
]
awk -F ',' '$2 == 1 { print $4, $5 }' titanic_train.csv | head -n 5
\end{lstlisting}

Выбрать строки из диапазона строк, который отвечают заданным шаблонам
\begin{lstlisting}[
style = bash,
numbers = none
]
awk -F ',' '/Graham/, /Palsson/' titanic_train.csv
\end{lstlisting}

Просуммировать все элементы 3-его столбца и вывести результат
\begin{lstlisting}[
style = bash,
numbers = none
]
awk -F ',' '{ sum += $3 } END { print sum }' file_name.csv  # 4.89428e+08
\end{lstlisting}

Вывести группу строк файла на основе их номеров строк
\begin{lstlisting}[
style = bash,
numbers = none
]
awk -F ',' 'NR == 2, NR == 4' file_name.csv
\end{lstlisting}

Выбрать только те строки, в которых встречается подстрока <<Mrs.>> и записать их в файл \verb|mrs_output.txt|
\begin{lstlisting}[
style = bash,
numbers = none
]
awk -F ',' '/Mrs./ { print > "mrs_output.txt" }' titanic_train.csv
\end{lstlisting}

Найти idx-файл и отрезать в его имени часть <<pack->>

\begin{lstlisting}[
style = bash,
numbers = none
]
ls -l .git/objects/pack/ | grep -iE '*.idx' | awk -F ' ' '{ print $9 }' | sed 's/.*-//'
\end{lstlisting}

Прочитать файл \texttt{master} в стандартный поток вывода, оставить только последнюю строку и вывести 1-ый столбец, а также все столбцы, начиная с 8-ого
\begin{lstlisting}[
style = bash,
numbers = none
]
cat .git/logs/refs/heads/master | tail -1 | cut -d ' ' -f1,8-
\end{lstlisting}


\subsection{Работа с архивами}

Собрать csv-файлы текущей директории в \emph{несжатый} tar-архив 
\begin{lstlisting}[
style = bash,
numbers = none	
]
tar -cvf only_csv_files.tar *.csv
du -sh only_csv_files.tar # 3,8M	only_csv_files.tar
\end{lstlisting}

Собрать csv-файлы текущей директории в \emph{сжатый} tar-архив 
\begin{lstlisting}[
style = bash,
numbers = none	
]
tar -czvf only_csv_files_zip.tar.gz *.csv  # 920K	only_csv_files_zipp.tar.gz
\end{lstlisting}

Вывести список файлов tar-архива
\begin{lstlisting}[
style = bash,
numbers = none	
]
tar -tf only_csv_files_zip.tar.gz
\end{lstlisting}

\subsection{Приемы работы с потоковым редактором sed}

Заменить в yaml-файле тип \verb|!!int| на \verb|!!float|
\begin{lstlisting}[
style = bash,
numbers = none	
]
# приходится экранировать восклицательный знак
sed s/\!\!int/\!\!float/g config.yaml
\end{lstlisting}



% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{sobel:linux-2011}{ Собель М. Linux. Администрирование и системное программирование. 2-е изд. -- СПб.: Питер, 2011. -- 880 с. }
	
	\bibitem{shotts:linux-2017}{ Шоттс У. Командная строка Linux. Полное руководство. -- СПб.: Питер, 2017. -- 480 с. }
	
	\bibitem{robbins:vim-2013}{ Роббинс А., Ханна Э., Лэмб Л. Изучаем редакторы vi и Vim, 7-е издание. -- СПб.: Символ-Плюс, 2013. -- 512 с.}
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\end{document}
