\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Практика использования и наиболее полезные конструкции командной оболочки \texttt{bash}}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Сценарии командной оболочки \texttt{bash}}

\subsection{Особенности обработки выражений, заключенных в кавычки}

Строка в форме \verb|$'...'| умеет обрабатывать управляющие последовательности
\begin{lstlisting}[
style = bash,
numbers = none
]
$ echo $'python\nfortran'
# выведет две строки, разбитые символом перевода строки
# python
# fortran
\end{lstlisting}

Строка в форме \verb|"..."| умеет корректно обрабатывать подстановку значений переменных, арифметических выражений и подстановку команд
\begin{lstlisting}[
style = bash,
numbers = none
]
$ EMAIL = 'leor.finkelberg@yandex.ru'
$ echo $EMAIL  # leor.finkelberg@yandex.ru
$ echo "My email: '$EMAIL'"  # My email:'leor.finkelberg@yandex.ru'
$ echo "In this catalogy `ls -l | wc -l` files"  # In this catalogy 10 files
$ echo "$INT % 2 -> $(($INT % 2))"  # 8 % 2 -> 0
$ echo "result = <<`find . -name 'cheat*.tex' | xargs grep -inE 'tab.*ofcont*'`>>"
                                                      # result = <<21:\tableofcontents>>
\end{lstlisting}



\subsection{Переменные, встроенные в оболочку}



\subsection{Формат файла сценария}

Для того чтобы успешно создать и запустить сценарий командной оболочки требуется:
\begin{enumerate}
	\item Написать сценарий,
	
	\item Сделать сценарий исполняемым,
	
	\item Поместить сценарий в каталог, где командная оболочка сможет найти его.
\end{enumerate}

Простой пример в качестве иллюстрации
\begin{lstlisting}[
style = bash,
title = {\sffamily bash\_test.sh},
numbers = none
]
#!/bin/bash
echo "This is number of command line args: $#"
\end{lstlisting}

Сочетание символов \verb|#!| -- это специальная конструкция, которая называется \emph{shebang} (произносится как <<ше-бенг>>) и сообщает системе имя интерпретатора, который должен использоваться для выполнения следующего за ним текста сценария. Каждый сценарий командной оболочки должен включать это определение в первой строке.

Команда <<точка>> (\texttt{.}) является синонимом \texttt{source}, встроенной команды, которая читает указанный файл и интерпретирует его как ввод с клавиатуры \cite[\strbook{349}]{shotts:linux-2017}.

\subsection{Разрешение на выполнение}

Теперь нужно сделать этот файл исполняемым
\begin{lstlisting}[
style = bash,
numbers = none
]
$ chmod +x bash_test.sh
$ ls -l bash_test.sh
# выведет
# -rwxr-xr-x 1 ADM 197121 31 май 19 02:55 bash_test.sh*
\end{lstlisting}

\subsection{Местоположение файла сценария}

Теперь можно вызывать этот скрипт
\begin{lstlisting}[
style = bash,
numbers = none
]
$ ./bash_test.sh 10 20
# выведет
# This is number of command line args: 2
\end{lstlisting}

Но чтобы вызвать сценарий, необходимо добавить явный путь перед его именем. Для того чтобы можно было вызывать этот сценарий из любой точки системы, следует добавить его в переменную окружения \texttt{PATH}. Как известно, система просматривает каталоги по списку всякий раз, когда требуется найти исполняемую программу, если путь к ней не указан явно. Список каталогов храниться в как раз в переменной окружения \texttt{PATH}.

Она содержит список каталогов, перечисленных через двоеточие
\begin{lstlisting}[
style = bash,
numbers = none
]
$ echo $PATH
# выведет
# /c/Users/ADM/bin:/mingw64/bin:/usr/local/bin:/usr/bin:/bin:/mingw64/bin:/usr/bin:\
# /c/Users/ADM/bin:/c/Program Files (x86)/Common Files/Oracle/Java/javapath:\
# /c/Program Files (x86)/Intel/iCLS Client:/c/Program Files/Intel/iCLS Client ... etc
\end{lstlisting}

К слову, для более удобного просмотра вывода (пути разделяются символом <<\texttt{:}>>), можно воспользоваться следущей процедурой с привлечением редактора \texttt{Vim}:
\begin{itemize}
	\item Перенаправляем стандартный поток вывода в файл \texttt{paths.txt}: \\\verb|echo $PATH > paths.txt|
	
	\item Открываем файл редактором \texttt{Vim}\\\verb|vim paths.txt|
	
	\item Сочетанием клавиш \texttt{qa}\footnote{Начать запись в именованный регистр \texttt{"a}} открываем журнал записи пользовательских сценариев (внизу экрана появится строка <<\verb|запись @a|>>),
	
	\item Теперь можно выполнить нужную нам последовательность команд для первого символа <<\texttt{:}>>. Например \verb|f:xi<CR><Esc>q|, что означает следующее: найти слева направо символ <<\texttt{:}>>, удалить символ, который будет находится под курсором (т.е. символ <<\texttt{:}>>), перейти в режим ВСТАВКИ (\texttt{i}), нажать клавишу \texttt{Enter} для перехода на следующую строку в режиме ВСТАВКИ, нажать клавишу \texttt{Esc} для выхода из режима ВСТАВКИ и, наконец, закончить запись (\texttt{q})\footnote{Проверить содержимое регистра можно так \texttt{:reg a}},
	
	\item Записав сценарий, можно воспользоваться командой \texttt{normal}\footnote{Здесь задается произвольное большое число, указывающее число повторений команды. Еще очень важный момент заключается в том, что эта команда выполняется параллельно, а не последовательно} \\\verb|:%normal! 100@a|
\end{itemize}

Результат будет выглядеть так
\begin{lstlisting}[
numbers = none
]
/c/Users/ADM/bin
/mingw64/bin
/usr/local/bin
/usr/bin
/bin
/mingw64/bin
\end{lstlisting}

В большинстве \texttt{Unix}-подобных операционных систем в переменную \texttt{PATH} включается каталог \verb|bin| в \emph{домашнем каталоге пользователя}, чтобы дать пользователям выполнять собственные программы.

То есть если создать каталог \verb|~/bin| и поместить сценарий в него, то наш сценарий можно будет запускать из любой точки системы
\begin{lstlisting}[
numbers = none
]
$ mkdir ~/bin
$ mv bash_test.sh ~/bin
\end{lstlisting}

Если каталог отсутствует в переменной \verb|PATH|, его легко туда добавить, включив следующую строку в файл \verb|~/.bash_profile|
\begin{lstlisting}[
numbers = none
]
export PATH=~/bin:${PATH}
\end{lstlisting}

Команда \texttt{export} устанавливает \emph{переменную окружения}, или другими словами экспортирует переменную, делая ее {переменной окружения}. Здесь <<\texttt{:}>> это просто символ-разделитель, а конструкция \verb|${PATH}| разворачивается в список путей, разделенных символом <<\texttt{:}>>.

\subsection{Выбор местоположения для сценариев}

Каталог \verb|~/bin| хорошо подходит для сценария, если этот сценарий предназначен для \emph{личного} использования. Сценарии, которые должны быть доступны \emph{всем} пользователям в системе, лучше размещать в традиционном местоположении -- в каталоге \verb|/usr/local/bin|.

В большинстве случаев программное обеспечение созданное в \emph{локальной} системе, будь то сценарий или скомпилированные программы, следует помещать в иерархию каталогов \verb|/usr/local|, а не \verb|/bin| или \verb|/usr/bin|. Последние два каталога, как определено стандартом иерархии файловой системы \texttt{Linux}, предназначены только для файлов, поставляемых создателями дистрибутива \texttt{Linux}.

\subsection{Присваивание значений переменным и константам}

Командная оболочка не заботиться о типах значений, присваиваемых переменным. Она все значения интерпретирует как \emph{строки}. Между именем переменной и оператором присваивания не должно быть пробелов. Значение может состоять из чего угодно, что можно развернуть в строку
\begin{lstlisting}[
style = bash,
numbers = none
]
a=z                  # Присвоить переменной a строку "z"
b="a string"         # Внутренние пробелы должны находиться в кавычках
c="a string and $b"  # При присваивании допускается выполнять подстановку,
                     # например, значений других переменных
d=$(ls -l foo.txt)   # Результат выполнения команды
e=$((5*7))           # Подстановка результата арифметического выражения
f="\t\ta string\n"   # Экранирование последовательности, такие как
                     # символы табуляции и перевода строки
\end{lstlisting}

При использовании подстановки имена переменных можно заключить в \emph{необязательные фигурные скобки} \verb|{}|. Это пригодится в том случае, когда имя переменной становится неоднозначным в окружающем контексте.

Например
\begin{lstlisting}[
numbers = none
]
$ filename="myfile"
$ touch $filename
$ mv $filename ${filename}1  # переименовывает файл myfile -> myfile1
\end{lstlisting}

Добавив фигурные скобки, мы гарантировали, что командная оболочка не будет интерпретировать последний символ \texttt{1} как часть имени новой (и пустой) переменной.

Существует еще один метод вывода текста, который называется \emph{встроенным документом} или \emph{встроенным сценарием}. Встроенный документ -- это дополнительная форма перенаправления ввода/вывода, которая передает текст, встроенный в сценарий, на стандартный ввод команд.

Действует это перенаправление так:
\begin{lstlisting}[
numbers = none
]
команда << индикатор
текст
индикатор
\end{lstlisting}

Например
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

TITLE="System Information Report Fort $HOSTNAME"
CURRENT_TIME=$(date +"%x %r %Z")
TIME_STAMP="Generated $CURRENT_TIME, by $USER"

cat << _EOF_
<HTML>
    <HEAD>
        <TITLE>$TITLE</TITLE>
    </HEAD>
    <BODY>
        <H1>$TITLE</H1>
        <P>$TIME_STAMP</P>
    </BODY>
</HTML>
_EOF_
\end{lstlisting}

К слову, для того чтобы заменить \verb|$name| на \verb|${name}| в сценарии можно воспользоваться такой конструкцией
\begin{lstlisting}[
style =bash,
numbers = none
]
:%s/>\$\(.*\)</>${\1}</c
------------------------
:%s  # произвести замену во всех строках файла
   /  # разделитель
    >\$\(.*\)<  # поисковый шаблон; например, >$TITLE<
              /  # разделитель
               >${\1}<  # шаблон подстановки
                      /c  # замена с подтверждением по каждому совпадению
\end{lstlisting}

Эта конструкция ищет совпадение с шаблоном во \emph{всех} строках сценария (\verb|%|). Подшаблон \verb|>\$\(.*\)<| совпадает, например, с подстрокой \verb|>$TITLE<|, и при этом \texttt{TITLE} попадает в группу №1 (к ней можно обращаться как \verb|\1|). Теперь можно \verb|>$TITLE<| заменить на \verb|>${\1}<|. Эта часть шаблона воспринимается <<как есть>>, т.е. ничего дополнительно экранировать не нужно. Параметр \texttt{c} требует подтверждение замены каждый раз, когда находит подстроку отвечающую поисковому шаблону.

На роль индикатора была выбрана строка \verb|_EOF_|, и она отмечает конец встроенного текста. Строка-индикатор должна находиться в отдельной строке, одна, и за ней не должно следовать никаких пробелов.

Если заменить оператор перенаправления \verb|<<| на \verb|<<-|, то командная оболочка будет игнорировать начальные символы табуляции во встроенном документе. Для того чтобы блок встроенного документа работал корректно для форматирования тела блока необходимо использовать только ТАБУЛЯЦИЮ, поэтому в \texttt{Vim} придется отключить преобразование табуляции в пробелы (закомментировать строку \verb|set expandtab|). Благодаря этому во встроенный документ можно добавить отступы для большей удобочитаемости
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

FTP_SERVER=ftp.nl.debian.org
FTP_PATH=/debian/dists/lenny/main/installer-i386/current/images/cdrom
REMOTE_FILE=debian-cd_info.tar.gz

ftp -n <<- _EOF_
    open $FTP_SERVER            # здесь строго ТАБУЛЯЦИЯ!
    user anonymous me@linuxbox  # здесь строго ТАБУЛЯЦИЯ!
    cd $FTP_PATH                # здесь строго ТАБУЛЯЦИЯ!
    hash                        # здесь строго ТАБУЛЯЦИЯ!
    get $REMOTE_FILE            # здесь строго ТАБУЛЯЦИЯ!
    bye                         # здесь строго ТАБУЛЯЦИЯ!
    _EOF_                       # здесь строго ТАБУЛЯЦИЯ!
ls -l $REMOTE_FILE
\end{lstlisting}

Еще можно перенаправлять вывод, организованный с помощью \verb|<<-|, в файл
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

USER="leor.finkelberg"

report_home_space () {
    if [[ $(id -u) -eq 0 ]]; then
        cat <<- _EOF_ > ./contfile.txt  # <- NB          # здесь строго ТАБУЛЯЦИЯ!
            <H2>Home Space Utilization (All Users)</H2>  # здесь строго ТАБУЛЯЦИЯ!
            <PRE>$(du -sh .)</PRE>                       # здесь строго ТАБУЛЯЦИЯ!
            _EOF_                                        # здесь строго ТАБУЛЯЦИЯ!
...
\end{lstlisting}

Конструкция \verb|cat <<- _EOF_ > ./contfile.txt| перезаписывает файл \texttt{contfile.txt} при каждом запуске сценария. Если требуется <<дозаписать>> файл, то следует использовать конструкцию \verb|cat <<- _EOF_ >> ./contfile.txt|.

Можно вывод команды \texttt{cat} направить как в стандартный поток вывода (терминал), так и в файл с помощью команды \texttt{tee}\footnote{Утилита \texttt{tee} копирует стандартный ввод на стандартный вывод, а также в один или несколько файлов \cite{sobel:linux-2011}}
\begin{lstlisting}[
style = bash,
numbers = none
]
report_home_space () {
    if [[ $(id -u) -eq 0 ]]; then
        cat <<- _EOF_ | tee ./contfile.txt  # <- NB
                ...
                _EOF_
    ...
}
\end{lstlisting}

Без ключей утилита \texttt{tee} переписывает файл вывода, если они существуют, и реагирует на прерывания. Ключ \verb|-a| заставляет утилиту добавлять вывод к существующим файлам вместо их переписывания.

\subsection{Функции}

Функции имеют две синтаксические формы. Первая выглядит так
\begin{lstlisting}[
numbers = none
]
function fun_name {
    commands
    return 
}
\end{lstlisting}

Вторая форма выгладит так
\begin{lstlisting}[
numbers = none
]
fun_name () {
    commands
    return
}
\end{lstlisting}

Обе формы эквивалентны и могут использоваться одна вместо другой. Ниже приводится сценарий, демонстрирующий использование функций командной оболочки
\begin{lstlisting}[
style = bash
]
#!/bin/bash

function funct {
    echo "Step 2"
    return
}

echo "Step 1"  # Step 1
funct          # Step 2
echo "Step 3"  # Step 3
\end{lstlisting}

Когда командная оболочка читает сценарий, она пропускает строки с 1-ой по 7-ую, так как они содержат только определение функции. Выполнение начинается со строки 8 с команды \texttt{echo}. Строка 9 вызывает функцию \texttt{funct}, и командная оболочка выполняет функцию как любую другую команду. Управление передается в строку 4, и выполняется вторая команда \texttt{echo}.

Команда \texttt{return} в этой строке завершает выполнение функции и возвращает управление в строку, следующую за вызовом функции. После этого выполняется заключительная команда \texttt{echo}. Функции должны быть определены в сценарии до их вызова.

Имена функций подчиняются тем же правилам, что и имена переменных. Функция должна содержать хотя бы одну команду. Команда \texttt{return} (которая является необязательной) помогает удовлетворить это требование.

Примеры использования функций с \emph{локальными переменными}

\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

foo=0  # глобальная переменная

funct_1 () {
    local foo  # переменная `foo` локальная для `funct_1`
    foo=1
    echo "funct_1: foo = $foo"
}

# для вызова функции
funct_1
\end{lstlisting}

Локальные переменные объявляются добавлением слова \texttt{local} перед именем переменной. В результате создается переменная, локальная по отношению к функции, в которой она определена. Когда выполнение выйдет за пределы функции, переменная перестанет существовать.

Рассмотрим такую функцию
\begin{lstlisting}[
style = bash,
numbers = none
]
report_disk_space () {
    cat <<- _EOF_
        <H2>Disk Space Utilization</H2>  # здесь строго ТАБУЛЯЦИЯ!
        <PRE>$(df -h)</PRE>              # здесь строго ТАБУЛЯЦИЯ!
        _EOF_                            # здесь строго ТАБУЛЯЦИЯ!
    return
}

# вызов функции
report_disk_space
\end{lstlisting}

Она получает информацию о дисковом пространстве с помощью команды \verb|df -h|.

\subsection{Ветвление}

Инструкция \texttt{if} имеет следующий синтаксис
\begin{lstlisting}[
style = bash,
numbers = none
]
if commands; then
    commands
[elif commands; then
    commands...]
[else
    commands]
fi
\end{lstlisting}

В командной оболочке \texttt{bash} поддерживается еще один способ ветвления. Операторы \verb|&&| и \verb|||| действуют подобно логическим операторам в составной команде \verb|[[...]]|. Они имеют следующий синтаксис
\begin{lstlisting}[
style = bash,
numbers = none
]
command1 && command2
\end{lstlisting}
и
\begin{lstlisting}[
style = bash,
numbers = none
]
command1 || command2
\end{lstlisting}

В последовательности с оператором \verb|&&| первая команда выполняется всегда, а вторая -- только если первая завершилась успешно. В последовательности с оператором \verb|||| первая команда выполняется всегда, а вторая -- только если первая завершилась неудачей.

Например
\begin{lstlisting}[
style = bash,
numbers = none
]
# если каталога `temp` не существует, то его нужно создать
$ [[ -d temp ]] || mkdir temp
\end{lstlisting}


\subsection{Современная версия команды test}

Улучшенная версия команды \texttt{test} выглядит так
\begin{lstlisting}[
style = bash,
numbers = none
]
[[ выражение ]]
\end{lstlisting}

Команда \texttt{test} и ее формы (\verb|[...]|, \verb|[[...]]|) возвращают \emph{код завершения}, показывающий, что выражение либо истинно -- \texttt{true} (0), либо ложно -- \texttt{false} (не 0). А вот самое \texttt{выражение} возвращает истинное (\texttt{true}) или ложное (\texttt{false}) значение.

Команда \verb|[[...]]| очень похожа на команду \verb|[...]|, но добавляет новое выражение для проверок строк \verb|строка1 =~ регулярное_выражение|.

Например можно проверить отвечает ли заданное число регулярному выражению
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

INT=-5

if [[ "$INT" =~ ^-?[0-9]+$ ]]; then
    if [ $INT -eq 0 ]; then
        echo "INT is zero."
    else
        if [ $INT -lt 0 ]; then
            echo "INT is negative."
        else
            echo "INT is positive."
        fi
        if [ $((INT % 2 )) -eq 0 ]; then
            echo "INT is even."
        else
            echo "INT is odd."
        fi
    fi
else
    echo "INT is not an integer." >&2
    exit 1
fi
\end{lstlisting}

В команде \verb|[[...]]| поддерживаются \emph{классы символов}\footnote{Класс символов POSIX состоит из ключевых слов, заключенных между \texttt{[:} и \texttt{:]}. Эти конструкции должны находится в квадратных скобках скобкового выражения. Например, \texttt{[[:alpha:]!]} соответствует любому одиночному символу или восклицательному знаку \cite[\strbook{98}]{robbins:vim-2013}} POSIX. Ключевые слова описывают различные классы символов, такие как алфавитные, управляющие символы и пр.} POSIX, например
\begin{lstlisting}[
style = bash,
numbers = none
]
$ EMAIL="leor.finkelberg@yandex.ru"
$ if [[ "$EMAIL" =~ ^[[:alpha:]]+\.[[:alpha:]]+@[[:alpha:]]+\.ru$ ]]; then echo 'OK'; fi
\end{lstlisting}

Еще одна дополнительная особенность \verb|[[...]]|: оператор \verb|==| поддерживает сопоставление с шаблонами по аналогии с механизмом подстановки путей. Например
\begin{lstlisting}[
style = bash,
numbers = none
]
$ FILE="foo.bar"
$ if [[ $FILE == foo.* ]]; then
> echo "$FILE matches pattern 'foo.*'"
>fi
# foo.bar matches pattern 'foo.*'
\end{lstlisting}

Или можно воспользоваться регулярным выражением
\begin{lstlisting}[
style = bash,
numbers = none
]
$ FILE="foo.bar"
$ if [[ $FILE =~ ^foo\..+$ ]]; then echo 'OK'; fi
# OK
\end{lstlisting}

В дополнение к составной команде \verb|[[...]]| \texttt{bash} поддерживает также составную команду \verb|((...))|, которую удобно использовать для работы с целыми числами.

Команда \verb|((...))| применяется для \emph{проверки истинности арифметических выражений}. Арифметическое выражение считается \emph{истинным}, если его \emph{результат отличается от нуля}.

Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

INT=-5

if [[ "$INT" =~ ^-?[0-9]+$ ]]; then
    if (( $INT == 0 )); then
        echo "INT is zero."
    ...
    fi
    if (( $INT % 2 )); then
        echo "INT is even."
    else
        echo "INT is odd."
...
\end{lstlisting}

\subsection{Объединение выражений}

Команда \verb|[[...]]| поддерживает три логические операции: И (\verb|&&|), ИЛИ (\verb||||) и НЕ (\verb|!|).

Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

MIN_VAL=1
MAX_VAL=100
INT=50

if [[ "$INT" =~ ^-?[0-9]+$ ]]; then
    if [[ INT -ge MIN_VAL && INT -le MAX_VAL ]]; then
        echo "$INT is whithin $MIN_VAL to $MAX_VAL."
    else
        echo "$INT is out of range."
    fi
else
    else "INT is not an integer." >&2
    exit 1
fi
\end{lstlisting}

Логические блоки можно заключать в круглые скобки
\begin{lstlisting}[
style = bash,
numbers = none
]
...
if [[ ($INT -lt 0) && ($INT -gt 10) ]]; then
    echo ...
\end{lstlisting}

Еще с \verb|[[...]]| можно сочетать подстановку \verb|$(...)| и вычисления \verb|(...)|
\begin{lstlisting}[
style = bash,
numbers = none
]
...
if [[ ($INT -gt 0) && $(($INT % 2)) -eq 0 ]]; then
    echo ...
\end{lstlisting}

Узнать имеет ли текущий пользователь права на чтение всех домашних каталогов можно следующим образом
\begin{lstlisting}[
style = bash,
numbers = none
]
USER="leor.finkelberg"

report_home_space () {
    if [[ $(id -u) -eq 0 ]]; then
        cat <<- _EOF_
            <H2>Home Space Utilization (All Users)</H2>  # здесь строго ТАБУЛЯЦИЯ!
            <PRE>$(du -sh .)</PRE>                       # здесь строго ТАБУЛЯЦИЯ!
            _EOF_                                        # здесь строго ТАБУЛЯЦИЯ!
    else
        cat <<- _EOF_
            <H2>Home Space Utilization ($USER)</H2>      # здесь строго ТАБУЛЯЦИЯ!
            <PRE>$(du -sh $HOME)</PRE>                   # здесь строго ТАБУЛЯЦИЯ!
            _EOF_                                        # здесь строго ТАБУЛЯЦИЯ!
    fi
    return    
}

report_home_space
\end{lstlisting}

\subsection{Чтение и ввод с клавиатуры}

Команда \texttt{read} используется для чтения единственной строки со стандартного ввода. Синтаксис
\begin{lstlisting}[
style = bash,
numbers = none
]
read [-parameters] [var ...]
\end{lstlisting}

Если имя переменной не указано, строка с данными сохраняется в переменную \texttt{REPLY}.

Например, для того чтобы пользователь мог задать имя файла, в который сценарий будет перенаправлять вывод \verb|<<-|, можно воспользоваться ключом \texttt{-r}

\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

read -p "Enter filename: " filename  # <-

report_home_space () {
    if [[ $(id -u) -eq 0 ]]; then
        cat <<- _EOF_ | tee ./$filename  # <-
            ...
        _EOF_
    ...
}
\end{lstlisting}

Еще один простой пример
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

# читает пользовательский ввод
read -p "Enter integer number: " int

if [[ "$int" =~ ^-?[[:digit:]]+$ ]]; then
    if [ $int -eq 0 ]; then
        echo "$int is zero."
    else
        if [ $int -lt 0 ]; then 
            echo "$int is negative."
        else
            echo "$int is positive."
        fi
        if [ $((int % 2)) -eq 0 ]; then
            echo "$int is even."
        else
            echo "$int is odd."
        fi
    fi
else
    echo "Input value is not an integer." >&2
    exit 1
fi
\end{lstlisting}

Для того чтобы прочитать несколько значений, следует воспользоваться такой конструкцией
\begin{lstlisting}[
style = bash,
numbers = none
]
read -p "Enter one or more values > " var1 var2 var3 var4 var5

echo "var1 = '$var1'"
echo "var2 = '$var2'"
echo "var3 = '$var3'"
echo "var4 = '$var4'"
echo "var5 = '$var5'"
\end{lstlisting}

С помощью ключа \verb|-s| можно скрывать символы при вводе, а с помощью ключа \verb|-t| устанавливать время ожидания на ввод. Например
\begin{lstlisting}[
style = bash,
numbers = none
]
if read -t 10 -sp "Enter secret passphrase > " secret_pass; then
    echo -e "\nSecret passphrase = '$secret_pass'" 
    # флаг -e нужен для интерпретации управляющей последовательности
...
\end{lstlisting}

Здесь пользователю предлагается ввести секретный пароль за отведенные 10 сек. Если в течение этого времени ввод не был завершен, сценарий завершается с кодом ошибки. Поскольку в команду включен параметр \verb|-s|, символы пароля не выводятся на экран в процессе ввода.

\subsection{Выделение полей в строке ввода с помощью IFS}

Обычно командная оболочка выполняте разбиение ввода на слова перед передачей его команде \texttt{read}. Слова во вводе, разделенные одним или несколькими пробелами, становятся отдельными значениями и присваиваются командой \texttt{read} разным переменным.

Такое поведение командной оболочки регулируется переменной \texttt{IFS} (Internal Field Separator). По умолчанию переменная \texttt{IFS} хранит символы пробела, табуляции и перевода строки, каждый из которых может служить разделителем полей.

Изменяя значение переменной \texttt{IFS}, можно управлять делением ввода на поля перед передачей команде \texttt{read}. Например, пусть файл \verb|/etc/passwd| хранит строки данных, в которых поля отделяются друг от друга двоеточием. Присвоив переменной \texttt{IFS} значение, состоящее из единственного двоеточия, можно с помощью \texttt{read} прочитать содержимое \verb|/etc/passwd| и благополучно разделить строки на поля для присваивания разным переменным. Ниже приводится сценарий, который именно так и действует
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

# файл должен существовать до обращения и иметь
# содержание вида Leor:100:34345:Leor Finkelberg:~:bash
FILE="./passwd.txt"

# строка-приглашение
read -p "Enter a username > " user_name  # вводим, например, leor

# благодаря флагу `-i` имя пользователя можно задавать в нижнем регистре
# подстановка $user_name отрабатывает раньше, чем поиск по регулярному выражению
file_info=$(grep -iE "^$user_name:" $FILE)  # одна единственная строка из файла ./passwd.txt

if [[ -n "$file_info" ]]; then  # если строка непустая, то...
    IFS=":" read user pw uid gid name home shell <<< "$file_info"  # <-
    echo "User = '$user'"
    echo "UID = '$uid'"
    echo "GID = '$gid'"
    echo "Full Name = '$name'"
    echo "Home Dir. = '$home'"
    echo "Shell = '$shell'"
else
    echo "No such user '$user_name'" >&2
    exit 1
fi
\end{lstlisting}

Командная оболочка позволяет выполнять в одной строке одно или несколько операций присваивания значений переменным непосредственно \emph{перед} командной, на поведение которой эти переменные влияют. Они \emph{изменяют окружение}, в котором выполняется команда. Действие этих операций присваивания ности \emph{временный} характер, окружение изменяется только на время выполнения команды. В данном случае в переменной \texttt{IFS} сохраняет символ двоеточия.

То же самое можно выразить иначе
\begin{lstlisting}[
style = bash,
numbers = none
]
OLD_IFS="$IFS"
IFS=":"
read user pw uid gid name home shell <<< "$file_info"
IFS="$OLD_IFS"
\end{lstlisting}

Очевидно, что размещение операции присваивания перед командой позволяет получить более компактный код, действующий точно так же.

Оператор \verb|<<<| отмечает \emph{встроенную строку}. Встроенную строку (here string) простирается только до конца текущей строки кода. В данном примере строка из файла подается на стандартный ввод команды \texttt{read}.

Вот несколько любопытных примеров работы со встроенной строкой
\begin{lstlisting}[
style = bash,
numbers = none
]
$ string="This is a string of words."
$ read -r -a words <<< "$string"
$ echo "${words[0]}"  # This
$ echo "${words[1]}"  # is
...
\end{lstlisting}

\subsection{Проверка ввода}

Далее приводится пример программы, проверяющий входные данные разного вида
\begin{lstlisting}[
style = bash,
numbers = none
]
#!/bin/bash

clear  # очистить экран перед началом работы программы

invalid_input () {
    echo "Invalid input '$REPLY'" >&2
    exit 1
}

# переменная явно не указана, поэтому
# пользовательский ввод будет связан с переменной REPLY
read -p "Enter a single item > "

# пустой ввод (недопустимо!); если строка пустая, то вызывается функция `invalid_input`
[[ -z $REPLY ]] && invalid_input
# если в переданной строке более одного слова, вызывать функцию `invalid_input`
# ((...)) -> [true|false]
(( $(echo $REPLY | wc -w) > 1 )) && invalid_input

# введено допустимое имя файла
if [[ $REPLY =~ ^[-[:alnum:]\._]+$ ]]; then
    echo "'$REPLY' is a valid filename."
    if [[ -e $REPLY ]]; then
        echo "And file '$REPLY' exists."
    else
        echo "However, file '$REPLY' does not exists."
    fi

    if [[ $REPLY =~ ^-?[[:digit:]]*\.[[:digit:]]+$ ]]; then
        echo "'$REPLY' is a floating point number."
    else
        echo "'$REPLY' is not a floating point number."
    fi

    if [[ $REPLY =~ ^-?[[:digit:]]+$ ]]; then
        echo "'$REPLY' is an integer."
    else
        echo "'$REPLY' is not an integer."
    fi
else
    echo "The string '$REPLY' is not a valid filename."
fi
\end{lstlisting}

Для проверки числа слов в пользовательском вводе с тем же результатом можно было бы использовать и конструкцию
\begin{lstlisting}[
style = bash,
numbers = none
]
[[ $(echo "$REPLY" | wc -w) -gt 1 ]] && invalid_input
\end{lstlisting}


\section{Полезные конструкции оболочки \texttt{bash}}

Найти в корневом каталоге и всех подкатлогах (\texttt{/}), обычные файлы (\texttt{-type f}), измененные за последний день (\texttt{-mtime -l}), за исключением тех файлов, у которых есть суффикс \texttt{.o} (\texttt{! -name '*.o'})

\begin{lstlisting}[
language = cmd,
numbers = none
]
find / -type f -mtime -l ! -name '*.o'
\end{lstlisting}

Вывод имен файлов и удаление файлов с именами \texttt{core} или \texttt{junk} из рабочего каталога и всех его подкаталогов (круглые скобки обязательно отделяются пробелами)

\begin{lstlisting}[
language = cmd,
numbers = none
]
find . \( -name core -o -name junk \) -print -exec rm {} \;
\end{lstlisting}

Скопировать все \texttt{csv}-файлы из родительской директории (\texttt{..}) в текущую (\texttt{.})

\begin{lstlisting}[
language = cmd,
numbers = none
]
cp -ip ../*.csv
\end{lstlisting}

Скопировать файл из родительской директории в текущую директорию

\begin{lstlisting}[
language = cmd,
numbers = none
]
cp -ip ../Cheat_sheet_Git/cheat_sheet_git.tex .
\end{lstlisting}

Скопировать одну директорию в другую

\begin{lstlisting}[
language = cmd,
numbers = none
]
cp -rip ../Cheat_sheet_Git/style_packages/ .
\end{lstlisting}

Переименовать файл

\begin{lstlisting}[
language = cmd,
numbers = none
]
mv cheat_sheet_git.tex cheat_sheet_bash.tex
\end{lstlisting}

Найти все файлы с расширением \texttt{*.csv} и выбрать из них те, в которых содержится строка \texttt{'state'} (для каждого файла, отвечающего поисковому шаблону, запускается свой процесс)

\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -name '*.csv' -exec grep -niE 'state' {} \;
\end{lstlisting}

Вывести список файлов из текущей директории и всех поддиректорий

\begin{lstlisting}[
language = cmd,
numbers = none
]
ls -l *
\end{lstlisting}

Найти среди файлов с расширением \texttt{*.py} те, в именах которых есть подстрока \texttt{'spark'} (используется конвейер)

\begin{lstlisting}[
language = cmd,
numbers = none
]
ls -l *.py | grep -iE 'spark'
\end{lstlisting}

Найти файлы с расширением \texttt{*.py} и к каждому из них применить команду \texttt{grep}, которая будет искать в файле подстроку \texttt{'argparse'} без учета регистра, с выводом номера строки, на которой она нашла искомую строку по регулярному выражению \texttt{'argparse'} (работает {\color{deepred} медленно}, так как для каждого файла, отвечающего поисковому шаблону запускается свой процесс)

\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -maxdepth 1 -name '*.py' -exec grep -inE 'argparse' {} \;
\end{lstlisting}

Альтернативный вариант с использованием \texttt{xargs} (работает значительно быстрее варианта с \texttt{-exec})

\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -maxdepth 1 -name '*.py' | xargs grep -inE 'argparse'
\end{lstlisting} 

Найти в файлах с расширением \texttt{*.tex} строку \texttt{'section'} без учета регистра и вывести три строки контекста
\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -name '*.tex' | xargs grep -iE 'section' -3
\end{lstlisting}

Вывести список пакетов, в именах которых встречается подстрока \texttt{'python'} с контекстом \texttt{'sql'}
\begin{lstlisting}[
language = cmd,
numbers = none
]
conda list | grep -inE 'python.*sql'
\end{lstlisting}

Получить информацию о доступном метсе на диске
\begin{lstlisting}[
language = cmd,
numbers = none
]
df -h
\end{lstlisting}

Скачать файл с тем же именем, что на удаленном репозитории 
\begin{lstlisting}[
language = cmd,
numbers = none
]
curl -O http://merionet.ru/yourfile.tar.gz
\end{lstlisting}

Скачать файл с удаленного репозитория с новым именем и/или путем
\begin{lstlisting}[
language = cmd,
numbers = none
]
curl -o newfile.tar.gz http:// merionet.ru /yourfile.tar.gz
\end{lstlisting}

Возобновить прерванную загрузку с того места, где она остановилась
\begin{lstlisting}[
language = cmd,
numbers = none
]
curl -C - -O http://merionet.ru/yourfile.tar.gz
\end{lstlisting}

Скачать несколько файлов 
\begin{lstlisting}[
language = cmd,
numbers = none
]
curl -O http://merionet.ru/info.html -O http://wiki.merionet.ru/about.html
\end{lstlisting}


\subsection{Переадресация ввода-вывода}

Перенаправить \emph{стандартный поток вывода} данных (дескриптор файла 1) и \emph{стандартный поток вывода ошибок} (дескриптор файла 2), которые возвращает \texttt{conda} с захватом всех пакетов, в именах которых встречается подстрока \texttt{'python'}, в файл с именем \texttt{test\_file.log} (временный поток вывода данных \texttt{\&1}). Если команда вернет ошибку, то сообщение ошибки перепишет содержимое файла \texttt{test\_file.log}
\begin{lstlisting}[
language = cmd,
numbers = none
]
conda list | grep -inE 'python' > test_file.log 2>&1
\end{lstlisting}

Более короткий вариант рассмотренной выше конструкции
\begin{lstlisting}[
language = cmd,
numbers = none
]
conda list | grep -inE 'python' &> test_file.log
\end{lstlisting}

Присоединить стандартный поток вывода данных и стандартный поток вывода ошибок к содержимому файла. Конструкция \texttt{rm df} возвращает сообщение об ошибке <<\texttt{rm: cannot remove 'df': No such file or directory}>>, которое можно добавить в файл
\begin{lstlisting}[
language = cmd,
numbers = none
]
rm df &>> test_file.txt
\end{lstlisting}

Найти в текущей директории файлы с расширением \texttt{.tex}, в именах которых встречается подстрока <<\texttt{bash}>>, перенаправить эти файлы утилите \texttt{grep}, которая будет искать в теле файлов строки, в которых встречается подстрока <<\texttt{vim}>>, причем стандартный поток вывода ошибок перенаправляется в <<черную дыру>>
\begin{lstlisting}[
language = cmd,
numbers = none
]
find . -name '*bash*.tex' | xargs grep -inE 'vim' 2>/dev/null
\end{lstlisting}

Записать строку в файл и дополнительно вывести строку в терминал
\begin{lstlisting}[
style = bash,
numbers = none
]
echo 'test string' | tee ./logfile.txt
\end{lstlisting}

\subsection{Информация об использовании дискового пространства}

Вывести размер директорий в Мегабайтах (\texttt{M})
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -BM
\end{lstlisting}

Вывести итоговый размер директории (\texttt{c}) в Мегабайтах (\texttt{M})
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -cBM
\end{lstlisting}

Перевести размеры директорий в понятный человеку формат
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -h
\end{lstlisting}

Вывести информацию об указанной директории в дружественном формате
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -sh style_packages/
\end{lstlisting}

Вывести размер папок текущей директории, не погружаясь глубже корневых папок
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -h -d 1
\end{lstlisting}
или так
\begin{lstlisting}[
language = cmd,
numbers = none
]
du --max-depth=1 -h
\end{lstlisting}

Вывести информацию об использовании дискового пространства иерархией каталога с подсчетом общего размера каталога и перенаправлением стандартного потока вывода ошибок в <<черную дыру>>
\begin{lstlisting}[
language = cmd,
numbers = none
]
du -ch -d 1 2>/dev/null
\end{lstlisting}

\section{Вспомогательные конструкции \texttt{Vim}}

\subsection{Регистры \texttt{Vim}}

Регистры \texttt{Vim} -- это всего лишь контейнеры для хранения текста. Их можно использовать как своеобразные буферы обмена копируя текст в регистры и вставляя его из регистров, или для записи макросов, сохраняя в них последовательности нажатий на клавиши.

\subsection{Макросы}

Клавиша \texttt{q} действует как своеобразная кнопка <<Запись>> и одновременно как кнопкаа <<Стоп>>. Чтобы начать запись последовательности нажатий на клавиши, необходимо ввести \verb|q{register}|, указав имя регистра, где будет сохранен макрос. 

Посмотреть содержимое регистра \verb|"a| можно с помощью \texttt{:reg}
\begin{lstlisting}[
language = cmd,
numbers = none
]
:reg a
\end{lstlisting}

Команда \verb|@{register}| служит для выполнения содержимого указанного регистра. То есть, если макрос записывался в регистр \verb|"a|, то вызывать нужно макрос из того регистра как \verb|@a|.

Макрос записанный, например в регистр \texttt{"a}, можно выполнить заданное число раз, указав число повторений, например так \verb|25@a|.

Если требуется, чтобы макрос выполнялся для каждой строки из заданного диапазона, то следует использовать команду \texttt{:normal}\footnote{Восклицательный знак для игноирования пользовательских настроек}
\begin{lstlisting}[
language = cmd,
numbers = none
]
:normal! 25@a
\end{lstlisting}



\subsection{Базовые концептуальные конструкции}

Перейти в ВИЗУАЛЬНЫЙ режим, выделить 2 <<слова>> (фрагмент текста) и скопировать в безымянный регистр (\verb|""|)
\begin{lstlisting}[
language = cmd,
numbers = none
]
v2wy
\end{lstlisting}

Вставить данные из регистра (именованного, неименованного и др.), не покидая режима вставки, можно с помощью сочетания клавиш \verb|<C-r>{registr}| (т.е. \texttt{Ctrl+C} и имя регистра). Пусть в \emph{регистре выделенного фрагмента} (\texttt{"*}) хранится какая-нибудь строка. С помощью команды \texttt{A} переходим в режим ВСТАВКИ в конец строки. Теперь строку и регистра можно вставить сочетанием \verb|<C-r>|. После этого под курсором появится символ \verb|"|. Клавиша \texttt{*} заменит символ \verb|"| содержимым регистра \verb|"*|.

\emph{Фрагмент} строки можно вставить слева от курсора с помощью команды \texttt{P} или справа от курсора с помощью команды \texttt{p}.

Если же копировалась строка \emph{целиком}, то команда \texttt{p} вставляет строку под текущей, а команда \texttt{P} -- над текущей.

Удалить слово, находясь внутри слова (т.е. на любой позиции в пределах слова), можно так
\begin{lstlisting}[
language = cmd,
numbers = none
]
diw
\end{lstlisting}

Аналогично можно удалить слово и перейти в режим ВСТАВКИ, находясь внутри слова
\begin{lstlisting}[
language = cmd,
numbers = none
]
ciw
\end{lstlisting}

Используя подобную конструкцию, можно удалить текст, заключенный в кавычки, и тут же перейти в режим ВСТАВКИ
\begin{lstlisting}[
language = cmd,
numbers = none
]
ci"
\end{lstlisting}

Захватить текущее слово в регистр \texttt{"a}
\begin{lstlisting}[
language = cmd,
numbers = none
]
"ayiw
\end{lstlisting}

Вырезать текущую строку в регистр \texttt{"b}
\begin{lstlisting}[
language = cmd,
numbers = none
]
"bdd
\end{lstlisting}

Захватить последовательность символов, заключенную в кавычки, в регистр \texttt{"b}
\begin{lstlisting}[
language = cmd,
numbers = none
]
"byi'
\end{lstlisting}

Захватить слово в неименованный регистр (\verb|""|)
\begin{lstlisting}[
language = cmd,
numbers = none
]
""yiw
\end{lstlisting}

Захватить последовательность символов от текущего положения курсора до конца строки в \emph{регистр захвата} (\texttt{"0}). Все что копируется с помощью \texttt{y} попадает в регистр захвата
\begin{lstlisting}[
language = cmd,
numbers = none
]
y$
\end{lstlisting}

Вставить данные из регистра захвата
\begin{lstlisting}[
language = cmd,
numbers = none
]
"0p
\end{lstlisting}

Захватить в \emph{регистр выделенного фрагмента} (\texttt{"*}) несколько слов
\begin{lstlisting}[
language = cmd,
numbers = none
]
v3wey
\end{lstlisting}




Вставить данные из именованного регистра \texttt{b}
\begin{lstlisting}[
language = cmd,
numbers = none
]
"bp	
\end{lstlisting}


% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	\bibitem{sobel:linux-2011}{ Собель М. Linux. Администрирование и системное программирование. 2-е изд. -- СПб.: Питер, 2011. -- 880 с. }
	
	\bibitem{shotts:linux-2017}{ Шоттс У. Командная строка Linux. Полное руководство. -- СПб.: Питер, 2017. -- 480 с. }
	
	\bibitem{robbins:vim-2013}{ Роббинс А., Ханна Э., Лэмб Л. Изучаем редакторы vi и Vim, 7-е издание. -- СПб.: Символ-Плюс, 2013. -- 512 с.}
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\end{document}
